// automatically generated by the FlatBuffers compiler, do not modify
// TOTALLY DID MODIFY :D


use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod flat_font {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum MetaInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MetaInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MetaInfo<'a> {
    type Inner = MetaInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> MetaInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MetaInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MetaInfoArgs<'args>) -> flatbuffers::WIPOffset<MetaInfo<'bldr>> {
      let mut builder = MetaInfoBuilder::new(_fbb);
      builder.add_format_version_minor(args.format_version_minor);
      if let Some(x) = args.creator { builder.add_creator(x); }
      builder.add_format_version(args.format_version);
      builder.finish()
    }

    pub const VT_CREATOR: flatbuffers::VOffsetT = 4;
    pub const VT_FORMAT_VERSION: flatbuffers::VOffsetT = 6;
    pub const VT_FORMAT_VERSION_MINOR: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn creator(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MetaInfo::VT_CREATOR, None)
  }
  #[inline]
  pub fn format_version(&self) -> u16 {
    self._tab.get::<u16>(MetaInfo::VT_FORMAT_VERSION, Some(3)).unwrap()
  }
  #[inline]
  pub fn format_version_minor(&self) -> u32 {
    self._tab.get::<u32>(MetaInfo::VT_FORMAT_VERSION_MINOR, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for MetaInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"creator", Self::VT_CREATOR, false)?
     .visit_field::<u16>(&"format_version", Self::VT_FORMAT_VERSION, false)?
     .visit_field::<u32>(&"format_version_minor", Self::VT_FORMAT_VERSION_MINOR, false)?
     .finish();
    Ok(())
  }
}

#[derive(ufoff_macros::FromUFO)]
pub struct MetaInfoArgs<'a> {
    pub creator: Option<flatbuffers::WIPOffset<&'a str>>,
    pub format_version: u16,
    pub format_version_minor: u32,
}
impl<'a> Default for MetaInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        MetaInfoArgs {
            creator: None,
            format_version: 3,
            format_version_minor: 0,
        }
    }
}
pub struct MetaInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MetaInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_creator(&mut self, creator: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetaInfo::VT_CREATOR, creator);
  }
  #[inline]
  pub fn add_format_version(&mut self, format_version: u16) {
    self.fbb_.push_slot::<u16>(MetaInfo::VT_FORMAT_VERSION, format_version, 3);
  }
  #[inline]
  pub fn add_format_version_minor(&mut self, format_version_minor: u32) {
    self.fbb_.push_slot::<u32>(MetaInfo::VT_FORMAT_VERSION_MINOR, format_version_minor, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MetaInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MetaInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MetaInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for MetaInfo<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("MetaInfo");
      ds.field("creator", &self.creator());
      ds.field("format_version", &self.format_version());
      ds.field("format_version_minor", &self.format_version_minor());
      ds.finish()
  }
}
pub enum FontInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FontInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FontInfo<'a> {
    type Inner = FontInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> FontInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FontInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FontInfoArgs<'args>) -> flatbuffers::WIPOffset<FontInfo<'bldr>> {
      let mut builder = FontInfoBuilder::new(_fbb);
      if let Some(x) = args.meh { builder.add_meh(x); }
      builder.finish()
    }

    pub const VT_MEH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn meh(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_MEH, None)
  }
}

impl flatbuffers::Verifiable for FontInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"meh", Self::VT_MEH, false)?
     .finish();
    Ok(())
  }
}
pub struct FontInfoArgs<'a> {
    pub meh: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FontInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        FontInfoArgs {
            meh: None,
        }
    }
}
pub struct FontInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FontInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_meh(&mut self, meh: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_MEH, meh);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FontInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FontInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FontInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for FontInfo<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("FontInfo");
      ds.field("meh", &self.meh());
      ds.finish()
  }
}
pub enum FlatFontOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FlatFont<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FlatFont<'a> {
    type Inner = FlatFont<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> FlatFont<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FlatFont { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FlatFontArgs<'args>) -> flatbuffers::WIPOffset<FlatFont<'bldr>> {
      let mut builder = FlatFontBuilder::new(_fbb);
      if let Some(x) = args.font_info { builder.add_font_info(x); }
      if let Some(x) = args.meta { builder.add_meta(x); }
      builder.finish()
    }

    pub const VT_META: flatbuffers::VOffsetT = 4;
    pub const VT_FONT_INFO: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn meta(&self) -> Option<MetaInfo<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<MetaInfo>>(FlatFont::VT_META, None)
  }
  #[inline]
  pub fn font_info(&self) -> Option<FontInfo<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FontInfo>>(FlatFont::VT_FONT_INFO, None)
  }
}

impl flatbuffers::Verifiable for FlatFont<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<MetaInfo>>(&"meta", Self::VT_META, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<FontInfo>>(&"font_info", Self::VT_FONT_INFO, false)?
     .finish();
    Ok(())
  }
}
pub struct FlatFontArgs<'a> {
    pub meta: Option<flatbuffers::WIPOffset<MetaInfo<'a>>>,
    pub font_info: Option<flatbuffers::WIPOffset<FontInfo<'a>>>,
}
impl<'a> Default for FlatFontArgs<'a> {
    #[inline]
    fn default() -> Self {
        FlatFontArgs {
            meta: None,
            font_info: None,
        }
    }
}
pub struct FlatFontBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FlatFontBuilder<'a, 'b> {
  #[inline]
  pub fn add_meta(&mut self, meta: flatbuffers::WIPOffset<MetaInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MetaInfo>>(FlatFont::VT_META, meta);
  }
  #[inline]
  pub fn add_font_info(&mut self, font_info: flatbuffers::WIPOffset<FontInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FontInfo>>(FlatFont::VT_FONT_INFO, font_info);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FlatFontBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FlatFontBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FlatFont<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for FlatFont<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("FlatFont");
      ds.field("meta", &self.meta());
      ds.field("font_info", &self.font_info());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_flat_font<'a>(buf: &'a [u8]) -> FlatFont<'a> {
  unsafe { flatbuffers::root_unchecked::<FlatFont<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_flat_font<'a>(buf: &'a [u8]) -> FlatFont<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<FlatFont<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `FlatFont`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flat_font_unchecked`.
pub fn root_as_flat_font(buf: &[u8]) -> Result<FlatFont, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<FlatFont>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `FlatFont` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_flat_font_unchecked`.
pub fn size_prefixed_root_as_flat_font(buf: &[u8]) -> Result<FlatFont, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<FlatFont>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `FlatFont` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flat_font_unchecked`.
pub fn root_as_flat_font_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FlatFont<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<FlatFont<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `FlatFont` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flat_font_unchecked`.
pub fn size_prefixed_root_as_flat_font_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FlatFont<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<FlatFont<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a FlatFont and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `FlatFont`.
pub unsafe fn root_as_flat_font_unchecked(buf: &[u8]) -> FlatFont {
  flatbuffers::root_unchecked::<FlatFont>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed FlatFont and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `FlatFont`.
pub unsafe fn size_prefixed_root_as_flat_font_unchecked(buf: &[u8]) -> FlatFont {
  flatbuffers::size_prefixed_root_unchecked::<FlatFont>(buf)
}
#[inline]
pub fn finish_flat_font_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<FlatFont<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_flat_font_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<FlatFont<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod FlatFont

