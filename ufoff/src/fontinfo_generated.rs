// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum FontInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

/// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/
pub struct FontInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FontInfo<'a> {
    type Inner = FontInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> FontInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FontInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FontInfoArgs<'args>) -> flatbuffers::WIPOffset<FontInfo<'bldr>> {
      let mut builder = FontInfoBuilder::new(_fbb);
      if let Some(x) = args.guidelines { builder.add_guidelines(x); }
      if let Some(x) = args.woffMetadataExtensions { builder.add_woffMetadataExtensions(x); }
      if let Some(x) = args.woffMetadataLicensee { builder.add_woffMetadataLicensee(x); }
      if let Some(x) = args.woffMetadataTrademark { builder.add_woffMetadataTrademark(x); }
      if let Some(x) = args.woffMetadataCopyright { builder.add_woffMetadataCopyright(x); }
      if let Some(x) = args.woffMetadataLicense { builder.add_woffMetadataLicense(x); }
      if let Some(x) = args.woffMetadataDescription { builder.add_woffMetadataDescription(x); }
      if let Some(x) = args.woffMetadataCredits { builder.add_woffMetadataCredits(x); }
      if let Some(x) = args.woffMetadataVendor { builder.add_woffMetadataVendor(x); }
      if let Some(x) = args.woffMetadataUniqueID { builder.add_woffMetadataUniqueID(x); }
      builder.add_woffMinorVersion(args.woffMinorVersion);
      builder.add_woffMajorVersion(args.woffMajorVersion);
      if let Some(x) = args.macintoshFONDName { builder.add_macintoshFONDName(x); }
      builder.add_macintoshFONDFamilyID(args.macintoshFONDFamilyID);
      builder.add_postscriptWindowsCharacterSet(args.postscriptWindowsCharacterSet);
      if let Some(x) = args.postscriptDefaultCharacter { builder.add_postscriptDefaultCharacter(x); }
      if let Some(x) = args.postscriptWeightName { builder.add_postscriptWeightName(x); }
      builder.add_postscriptNominalWidthX(args.postscriptNominalWidthX);
      builder.add_postscriptDefaultWidthX(args.postscriptDefaultWidthX);
      builder.add_postscriptBlueScale(args.postscriptBlueScale);
      builder.add_postscriptBlueShift(args.postscriptBlueShift);
      builder.add_postscriptBlueFuzz(args.postscriptBlueFuzz);
      if let Some(x) = args.postscriptStemSnapV { builder.add_postscriptStemSnapV(x); }
      if let Some(x) = args.postscriptStemSnapH { builder.add_postscriptStemSnapH(x); }
      if let Some(x) = args.postscriptFamilyOtherBlues { builder.add_postscriptFamilyOtherBlues(x); }
      if let Some(x) = args.postscriptFamilyBlues { builder.add_postscriptFamilyBlues(x); }
      if let Some(x) = args.postscriptOtherBlues { builder.add_postscriptOtherBlues(x); }
      if let Some(x) = args.postscriptBlueValues { builder.add_postscriptBlueValues(x); }
      builder.add_postscriptUnderlinePosition(args.postscriptUnderlinePosition);
      builder.add_postscriptUnderlineThickness(args.postscriptUnderlineThickness);
      builder.add_postscriptUniqueID(args.postscriptUniqueID);
      builder.add_postscriptSlantAngle(args.postscriptSlantAngle);
      if let Some(x) = args.postscriptFullName { builder.add_postscriptFullName(x); }
      if let Some(x) = args.postscriptFontName { builder.add_postscriptFontName(x); }
      builder.add_openTypeVheaCaretOffset(args.openTypeVheaCaretOffset);
      builder.add_openTypeVheaCaretSlopeRun(args.openTypeVheaCaretSlopeRun);
      builder.add_openTypeVheaCaretSlopeRise(args.openTypeVheaCaretSlopeRise);
      builder.add_openTypeVheaVertTypoLineGap(args.openTypeVheaVertTypoLineGap);
      builder.add_openTypeVheaVertTypoDescender(args.openTypeVheaVertTypoDescender);
      builder.add_openTypeVheaVertTypoAscender(args.openTypeVheaVertTypoAscender);
      builder.add_openTypeOS2StrikeoutPosition(args.openTypeOS2StrikeoutPosition);
      builder.add_openTypeOS2StrikeoutSize(args.openTypeOS2StrikeoutSize);
      builder.add_openTypeOS2SuperscriptYOffset(args.openTypeOS2SuperscriptYOffset);
      builder.add_openTypeOS2SuperscriptXOffset(args.openTypeOS2SuperscriptXOffset);
      builder.add_openTypeOS2SuperscriptYSize(args.openTypeOS2SuperscriptYSize);
      builder.add_openTypeOS2SuperscriptXSize(args.openTypeOS2SuperscriptXSize);
      builder.add_openTypeOS2SubscriptYOffset(args.openTypeOS2SubscriptYOffset);
      builder.add_openTypeOS2SubscriptXOffset(args.openTypeOS2SubscriptXOffset);
      builder.add_openTypeOS2SubscriptYSize(args.openTypeOS2SubscriptYSize);
      builder.add_openTypeOS2SubscriptXSize(args.openTypeOS2SubscriptXSize);
      builder.add_openTypeOS2WinDescent(args.openTypeOS2WinDescent);
      builder.add_openTypeOS2WinAscent(args.openTypeOS2WinAscent);
      builder.add_openTypeOS2TypoLineGap(args.openTypeOS2TypoLineGap);
      builder.add_openTypeOS2TypoDescender(args.openTypeOS2TypoDescender);
      builder.add_openTypeOS2TypoAscender(args.openTypeOS2TypoAscender);
      if let Some(x) = args.openTypeOS2CodePageRanges { builder.add_openTypeOS2CodePageRanges(x); }
      if let Some(x) = args.openTypeOS2UnicodeRanges { builder.add_openTypeOS2UnicodeRanges(x); }
      if let Some(x) = args.openTypeOS2FamilyClass { builder.add_openTypeOS2FamilyClass(x); }
      if let Some(x) = args.openTypeOS2Panose { builder.add_openTypeOS2Panose(x); }
      if let Some(x) = args.openTypeOS2VendorID { builder.add_openTypeOS2VendorID(x); }
      if let Some(x) = args.openTypeOS2Selection { builder.add_openTypeOS2Selection(x); }
      builder.add_openTypeOS2WeightClass(args.openTypeOS2WeightClass);
      builder.add_openTypeOS2WidthClass(args.openTypeOS2WidthClass);
      if let Some(x) = args.openTypeNameRecords { builder.add_openTypeNameRecords(x); }
      if let Some(x) = args.openTypeNameWWSSubfamilyName { builder.add_openTypeNameWWSSubfamilyName(x); }
      if let Some(x) = args.openTypeNameWWSFamilyName { builder.add_openTypeNameWWSFamilyName(x); }
      if let Some(x) = args.openTypeNameSampleText { builder.add_openTypeNameSampleText(x); }
      if let Some(x) = args.openTypeNameCompatibleFullName { builder.add_openTypeNameCompatibleFullName(x); }
      if let Some(x) = args.openTypeNamePreferredSubfamilyName { builder.add_openTypeNamePreferredSubfamilyName(x); }
      if let Some(x) = args.openTypeNamePreferredFamilyName { builder.add_openTypeNamePreferredFamilyName(x); }
      if let Some(x) = args.openTypeNameDescription { builder.add_openTypeNameDescription(x); }
      if let Some(x) = args.openTypeNameUniqueID { builder.add_openTypeNameUniqueID(x); }
      if let Some(x) = args.openTypeNameVersion { builder.add_openTypeNameVersion(x); }
      if let Some(x) = args.openTypeNameLicenseURL { builder.add_openTypeNameLicenseURL(x); }
      if let Some(x) = args.openTypeNameLicense { builder.add_openTypeNameLicense(x); }
      if let Some(x) = args.openTypeNameManufacturerURL { builder.add_openTypeNameManufacturerURL(x); }
      if let Some(x) = args.openTypeNameManufacturer { builder.add_openTypeNameManufacturer(x); }
      if let Some(x) = args.openTypeNameDesignerURL { builder.add_openTypeNameDesignerURL(x); }
      if let Some(x) = args.openTypeNameDesigner { builder.add_openTypeNameDesigner(x); }
      builder.add_openTypeHheaCaretOffset(args.openTypeHheaCaretOffset);
      builder.add_openTypeHheaCaretSlopeRun(args.openTypeHheaCaretSlopeRun);
      builder.add_openTypeHheaCaretSlopeRise(args.openTypeHheaCaretSlopeRise);
      builder.add_openTypeHheaLineGap(args.openTypeHheaLineGap);
      builder.add_openTypeHheaDescender(args.openTypeHheaDescender);
      builder.add_openTypeHheaAscender(args.openTypeHheaAscender);
      if let Some(x) = args.openTypeHeadFlags { builder.add_openTypeHeadFlags(x); }
      builder.add_openTypeHeadLowestRecPPEM(args.openTypeHeadLowestRecPPEM);
      if let Some(x) = args.openTypeHeadCreated { builder.add_openTypeHeadCreated(x); }
      if let Some(x) = args.openTypeGaspRangeRecords { builder.add_openTypeGaspRangeRecords(x); }
      if let Some(x) = args.note { builder.add_note(x); }
      builder.add_italicAngle(args.italicAngle);
      builder.add_ascender(args.ascender);
      builder.add_capHeight(args.capHeight);
      builder.add_xHeight(args.xHeight);
      builder.add_descender(args.descender);
      builder.add_unitsPerEm(args.unitsPerEm);
      if let Some(x) = args.trademark { builder.add_trademark(x); }
      if let Some(x) = args.copyright { builder.add_copyright(x); }
      builder.add_versionMinor(args.versionMinor);
      builder.add_versionMajor(args.versionMajor);
      if let Some(x) = args.styleMapStyleName { builder.add_styleMapStyleName(x); }
      if let Some(x) = args.styleMapFamilyName { builder.add_styleMapFamilyName(x); }
      if let Some(x) = args.styleName { builder.add_styleName(x); }
      if let Some(x) = args.familyName { builder.add_familyName(x); }
      builder.add_postscriptForceBold(args.postscriptForceBold);
      builder.add_postscriptIsFixedPitch(args.postscriptIsFixedPitch);
      builder.finish()
    }

    pub const VT_FAMILYNAME: flatbuffers::VOffsetT = 4;
    pub const VT_STYLENAME: flatbuffers::VOffsetT = 6;
    pub const VT_STYLEMAPFAMILYNAME: flatbuffers::VOffsetT = 8;
    pub const VT_STYLEMAPSTYLENAME: flatbuffers::VOffsetT = 10;
    pub const VT_VERSIONMAJOR: flatbuffers::VOffsetT = 12;
    pub const VT_VERSIONMINOR: flatbuffers::VOffsetT = 14;
    pub const VT_COPYRIGHT: flatbuffers::VOffsetT = 18;
    pub const VT_TRADEMARK: flatbuffers::VOffsetT = 20;
    pub const VT_UNITSPEREM: flatbuffers::VOffsetT = 22;
    pub const VT_DESCENDER: flatbuffers::VOffsetT = 24;
    pub const VT_XHEIGHT: flatbuffers::VOffsetT = 26;
    pub const VT_CAPHEIGHT: flatbuffers::VOffsetT = 28;
    pub const VT_ASCENDER: flatbuffers::VOffsetT = 30;
    pub const VT_ITALICANGLE: flatbuffers::VOffsetT = 32;
    pub const VT_NOTE: flatbuffers::VOffsetT = 34;
    pub const VT_OPENTYPEGASPRANGERECORDS: flatbuffers::VOffsetT = 36;
    pub const VT_OPENTYPEHEADCREATED: flatbuffers::VOffsetT = 38;
    pub const VT_OPENTYPEHEADLOWESTRECPPEM: flatbuffers::VOffsetT = 40;
    pub const VT_OPENTYPEHEADFLAGS: flatbuffers::VOffsetT = 42;
    pub const VT_OPENTYPEHHEAASCENDER: flatbuffers::VOffsetT = 44;
    pub const VT_OPENTYPEHHEADESCENDER: flatbuffers::VOffsetT = 46;
    pub const VT_OPENTYPEHHEALINEGAP: flatbuffers::VOffsetT = 48;
    pub const VT_OPENTYPEHHEACARETSLOPERISE: flatbuffers::VOffsetT = 50;
    pub const VT_OPENTYPEHHEACARETSLOPERUN: flatbuffers::VOffsetT = 52;
    pub const VT_OPENTYPEHHEACARETOFFSET: flatbuffers::VOffsetT = 54;
    pub const VT_OPENTYPENAMEDESIGNER: flatbuffers::VOffsetT = 56;
    pub const VT_OPENTYPENAMEDESIGNERURL: flatbuffers::VOffsetT = 58;
    pub const VT_OPENTYPENAMEMANUFACTURER: flatbuffers::VOffsetT = 60;
    pub const VT_OPENTYPENAMEMANUFACTURERURL: flatbuffers::VOffsetT = 62;
    pub const VT_OPENTYPENAMELICENSE: flatbuffers::VOffsetT = 64;
    pub const VT_OPENTYPENAMELICENSEURL: flatbuffers::VOffsetT = 66;
    pub const VT_OPENTYPENAMEVERSION: flatbuffers::VOffsetT = 68;
    pub const VT_OPENTYPENAMEUNIQUEID: flatbuffers::VOffsetT = 70;
    pub const VT_OPENTYPENAMEDESCRIPTION: flatbuffers::VOffsetT = 72;
    pub const VT_OPENTYPENAMEPREFERREDFAMILYNAME: flatbuffers::VOffsetT = 74;
    pub const VT_OPENTYPENAMEPREFERREDSUBFAMILYNAME: flatbuffers::VOffsetT = 76;
    pub const VT_OPENTYPENAMECOMPATIBLEFULLNAME: flatbuffers::VOffsetT = 78;
    pub const VT_OPENTYPENAMESAMPLETEXT: flatbuffers::VOffsetT = 80;
    pub const VT_OPENTYPENAMEWWSFAMILYNAME: flatbuffers::VOffsetT = 82;
    pub const VT_OPENTYPENAMEWWSSUBFAMILYNAME: flatbuffers::VOffsetT = 84;
    pub const VT_OPENTYPENAMERECORDS: flatbuffers::VOffsetT = 86;
    pub const VT_OPENTYPEOS2WIDTHCLASS: flatbuffers::VOffsetT = 88;
    pub const VT_OPENTYPEOS2WEIGHTCLASS: flatbuffers::VOffsetT = 90;
    pub const VT_OPENTYPEOS2SELECTION: flatbuffers::VOffsetT = 92;
    pub const VT_OPENTYPEOS2VENDORID: flatbuffers::VOffsetT = 94;
    pub const VT_OPENTYPEOS2PANOSE: flatbuffers::VOffsetT = 96;
    pub const VT_OPENTYPEOS2FAMILYCLASS: flatbuffers::VOffsetT = 98;
    pub const VT_OPENTYPEOS2UNICODERANGES: flatbuffers::VOffsetT = 100;
    pub const VT_OPENTYPEOS2CODEPAGERANGES: flatbuffers::VOffsetT = 102;
    pub const VT_OPENTYPEOS2TYPOASCENDER: flatbuffers::VOffsetT = 104;
    pub const VT_OPENTYPEOS2TYPODESCENDER: flatbuffers::VOffsetT = 106;
    pub const VT_OPENTYPEOS2TYPOLINEGAP: flatbuffers::VOffsetT = 108;
    pub const VT_OPENTYPEOS2WINASCENT: flatbuffers::VOffsetT = 110;
    pub const VT_OPENTYPEOS2WINDESCENT: flatbuffers::VOffsetT = 112;
    pub const VT_OPENTYPEOS2SUBSCRIPTXSIZE: flatbuffers::VOffsetT = 114;
    pub const VT_OPENTYPEOS2SUBSCRIPTYSIZE: flatbuffers::VOffsetT = 116;
    pub const VT_OPENTYPEOS2SUBSCRIPTXOFFSET: flatbuffers::VOffsetT = 118;
    pub const VT_OPENTYPEOS2SUBSCRIPTYOFFSET: flatbuffers::VOffsetT = 120;
    pub const VT_OPENTYPEOS2SUPERSCRIPTXSIZE: flatbuffers::VOffsetT = 122;
    pub const VT_OPENTYPEOS2SUPERSCRIPTYSIZE: flatbuffers::VOffsetT = 124;
    pub const VT_OPENTYPEOS2SUPERSCRIPTXOFFSET: flatbuffers::VOffsetT = 126;
    pub const VT_OPENTYPEOS2SUPERSCRIPTYOFFSET: flatbuffers::VOffsetT = 128;
    pub const VT_OPENTYPEOS2STRIKEOUTSIZE: flatbuffers::VOffsetT = 130;
    pub const VT_OPENTYPEOS2STRIKEOUTPOSITION: flatbuffers::VOffsetT = 132;
    pub const VT_OPENTYPEVHEAVERTTYPOASCENDER: flatbuffers::VOffsetT = 134;
    pub const VT_OPENTYPEVHEAVERTTYPODESCENDER: flatbuffers::VOffsetT = 136;
    pub const VT_OPENTYPEVHEAVERTTYPOLINEGAP: flatbuffers::VOffsetT = 138;
    pub const VT_OPENTYPEVHEACARETSLOPERISE: flatbuffers::VOffsetT = 140;
    pub const VT_OPENTYPEVHEACARETSLOPERUN: flatbuffers::VOffsetT = 142;
    pub const VT_OPENTYPEVHEACARETOFFSET: flatbuffers::VOffsetT = 144;
    pub const VT_POSTSCRIPTFONTNAME: flatbuffers::VOffsetT = 146;
    pub const VT_POSTSCRIPTFULLNAME: flatbuffers::VOffsetT = 148;
    pub const VT_POSTSCRIPTSLANTANGLE: flatbuffers::VOffsetT = 150;
    pub const VT_POSTSCRIPTUNIQUEID: flatbuffers::VOffsetT = 152;
    pub const VT_POSTSCRIPTUNDERLINETHICKNESS: flatbuffers::VOffsetT = 154;
    pub const VT_POSTSCRIPTUNDERLINEPOSITION: flatbuffers::VOffsetT = 156;
    pub const VT_POSTSCRIPTISFIXEDPITCH: flatbuffers::VOffsetT = 158;
    pub const VT_POSTSCRIPTBLUEVALUES: flatbuffers::VOffsetT = 160;
    pub const VT_POSTSCRIPTOTHERBLUES: flatbuffers::VOffsetT = 162;
    pub const VT_POSTSCRIPTFAMILYBLUES: flatbuffers::VOffsetT = 164;
    pub const VT_POSTSCRIPTFAMILYOTHERBLUES: flatbuffers::VOffsetT = 166;
    pub const VT_POSTSCRIPTSTEMSNAPH: flatbuffers::VOffsetT = 168;
    pub const VT_POSTSCRIPTSTEMSNAPV: flatbuffers::VOffsetT = 170;
    pub const VT_POSTSCRIPTBLUEFUZZ: flatbuffers::VOffsetT = 172;
    pub const VT_POSTSCRIPTBLUESHIFT: flatbuffers::VOffsetT = 174;
    pub const VT_POSTSCRIPTBLUESCALE: flatbuffers::VOffsetT = 176;
    pub const VT_POSTSCRIPTFORCEBOLD: flatbuffers::VOffsetT = 178;
    pub const VT_POSTSCRIPTDEFAULTWIDTHX: flatbuffers::VOffsetT = 180;
    pub const VT_POSTSCRIPTNOMINALWIDTHX: flatbuffers::VOffsetT = 182;
    pub const VT_POSTSCRIPTWEIGHTNAME: flatbuffers::VOffsetT = 184;
    pub const VT_POSTSCRIPTDEFAULTCHARACTER: flatbuffers::VOffsetT = 186;
    pub const VT_POSTSCRIPTWINDOWSCHARACTERSET: flatbuffers::VOffsetT = 188;
    pub const VT_MACINTOSHFONDFAMILYID: flatbuffers::VOffsetT = 190;
    pub const VT_MACINTOSHFONDNAME: flatbuffers::VOffsetT = 192;
    pub const VT_WOFFMAJORVERSION: flatbuffers::VOffsetT = 194;
    pub const VT_WOFFMINORVERSION: flatbuffers::VOffsetT = 196;
    pub const VT_WOFFMETADATAUNIQUEID: flatbuffers::VOffsetT = 198;
    pub const VT_WOFFMETADATAVENDOR: flatbuffers::VOffsetT = 200;
    pub const VT_WOFFMETADATACREDITS: flatbuffers::VOffsetT = 202;
    pub const VT_WOFFMETADATADESCRIPTION: flatbuffers::VOffsetT = 204;
    pub const VT_WOFFMETADATALICENSE: flatbuffers::VOffsetT = 206;
    pub const VT_WOFFMETADATACOPYRIGHT: flatbuffers::VOffsetT = 208;
    pub const VT_WOFFMETADATATRADEMARK: flatbuffers::VOffsetT = 210;
    pub const VT_WOFFMETADATALICENSEE: flatbuffers::VOffsetT = 212;
    pub const VT_WOFFMETADATAEXTENSIONS: flatbuffers::VOffsetT = 214;
    pub const VT_GUIDELINES: flatbuffers::VOffsetT = 216;

  /// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#generic-identification-information
  #[inline]
  pub fn familyName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_FAMILYNAME, None)
  }
  #[inline]
  pub fn styleName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_STYLENAME, None)
  }
  #[inline]
  pub fn styleMapFamilyName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_STYLEMAPFAMILYNAME, None)
  }
  #[inline]
  pub fn styleMapStyleName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_STYLEMAPSTYLENAME, None)
  }
  #[inline]
  pub fn versionMajor(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_VERSIONMAJOR, Some(0)).unwrap()
  }
  #[inline]
  pub fn versionMinor(&self) -> u32 {
    self._tab.get::<u32>(FontInfo::VT_VERSIONMINOR, Some(0)).unwrap()
  }
  /// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#generic-legal-information
  #[inline]
  pub fn copyright(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_COPYRIGHT, None)
  }
  #[inline]
  pub fn trademark(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_TRADEMARK, None)
  }
  /// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#generic-dimension-information
  #[inline]
  pub fn unitsPerEm(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_UNITSPEREM, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn descender(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_DESCENDER, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn xHeight(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_XHEIGHT, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn capHeight(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_CAPHEIGHT, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn ascender(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_ASCENDER, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn italicAngle(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_ITALICANGLE, Some(0.0)).unwrap()
  }
  /// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#generic-miscellaneous-information
  #[inline]
  pub fn note(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_NOTE, None)
  }
  /// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#gasp-range-record-format
  #[inline]
  pub fn openTypeGaspRangeRecords(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OpenTypeGaspRangeRecord<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OpenTypeGaspRangeRecord>>>>(FontInfo::VT_OPENTYPEGASPRANGERECORDS, None)
  }
  //// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#opentype-head-table-fields
  #[inline]
  pub fn openTypeHeadCreated(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPEHEADCREATED, None)
  }
  #[inline]
  pub fn openTypeHeadLowestRecPPEM(&self) -> u32 {
    self._tab.get::<u32>(FontInfo::VT_OPENTYPEHEADLOWESTRECPPEM, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeHeadFlags(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(FontInfo::VT_OPENTYPEHEADFLAGS, None)
  }
  /// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#opentype-hhea-table-fields
  #[inline]
  pub fn openTypeHheaAscender(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEHHEAASCENDER, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeHheaDescender(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEHHEADESCENDER, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeHheaLineGap(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEHHEALINEGAP, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeHheaCaretSlopeRise(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEHHEACARETSLOPERISE, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeHheaCaretSlopeRun(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEHHEACARETSLOPERUN, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeHheaCaretOffset(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEHHEACARETOFFSET, Some(0)).unwrap()
  }
  /// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#opentype-name-table-fields
  #[inline]
  pub fn openTypeNameDesigner(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMEDESIGNER, None)
  }
  #[inline]
  pub fn openTypeNameDesignerURL(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMEDESIGNERURL, None)
  }
  #[inline]
  pub fn openTypeNameManufacturer(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMEMANUFACTURER, None)
  }
  #[inline]
  pub fn openTypeNameManufacturerURL(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMEMANUFACTURERURL, None)
  }
  #[inline]
  pub fn openTypeNameLicense(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMELICENSE, None)
  }
  #[inline]
  pub fn openTypeNameLicenseURL(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMELICENSEURL, None)
  }
  #[inline]
  pub fn openTypeNameVersion(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMEVERSION, None)
  }
  #[inline]
  pub fn openTypeNameUniqueID(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMEUNIQUEID, None)
  }
  #[inline]
  pub fn openTypeNameDescription(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMEDESCRIPTION, None)
  }
  #[inline]
  pub fn openTypeNamePreferredFamilyName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMEPREFERREDFAMILYNAME, None)
  }
  #[inline]
  pub fn openTypeNamePreferredSubfamilyName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMEPREFERREDSUBFAMILYNAME, None)
  }
  #[inline]
  pub fn openTypeNameCompatibleFullName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMECOMPATIBLEFULLNAME, None)
  }
  #[inline]
  pub fn openTypeNameSampleText(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMESAMPLETEXT, None)
  }
  #[inline]
  pub fn openTypeNameWWSFamilyName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMEWWSFAMILYNAME, None)
  }
  #[inline]
  pub fn openTypeNameWWSSubfamilyName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPENAMEWWSSUBFAMILYNAME, None)
  }
  #[inline]
  pub fn openTypeNameRecords(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OpenTypeNameRecord<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OpenTypeNameRecord>>>>(FontInfo::VT_OPENTYPENAMERECORDS, None)
  }
  /// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#opentype-os2-table-fields
  #[inline]
  pub fn openTypeOS2WidthClass(&self) -> u32 {
    self._tab.get::<u32>(FontInfo::VT_OPENTYPEOS2WIDTHCLASS, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2WeightClass(&self) -> u32 {
    self._tab.get::<u32>(FontInfo::VT_OPENTYPEOS2WEIGHTCLASS, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2Selection(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(FontInfo::VT_OPENTYPEOS2SELECTION, None)
  }
  #[inline]
  pub fn openTypeOS2VendorID(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_OPENTYPEOS2VENDORID, None)
  }
  #[inline]
  pub fn openTypeOS2Panose(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(FontInfo::VT_OPENTYPEOS2PANOSE, None)
  }
  #[inline]
  pub fn openTypeOS2FamilyClass(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(FontInfo::VT_OPENTYPEOS2FAMILYCLASS, None)
  }
  #[inline]
  pub fn openTypeOS2UnicodeRanges(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(FontInfo::VT_OPENTYPEOS2UNICODERANGES, None)
  }
  #[inline]
  pub fn openTypeOS2CodePageRanges(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(FontInfo::VT_OPENTYPEOS2CODEPAGERANGES, None)
  }
  #[inline]
  pub fn openTypeOS2TypoAscender(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEOS2TYPOASCENDER, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2TypoDescender(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEOS2TYPODESCENDER, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2TypoLineGap(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEOS2TYPOLINEGAP, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2WinAscent(&self) -> u32 {
    self._tab.get::<u32>(FontInfo::VT_OPENTYPEOS2WINASCENT, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2WinDescent(&self) -> u32 {
    self._tab.get::<u32>(FontInfo::VT_OPENTYPEOS2WINDESCENT, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2SubscriptXSize(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEOS2SUBSCRIPTXSIZE, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2SubscriptYSize(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEOS2SUBSCRIPTYSIZE, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2SubscriptXOffset(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEOS2SUBSCRIPTXOFFSET, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2SubscriptYOffset(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEOS2SUBSCRIPTYOFFSET, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2SuperscriptXSize(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEOS2SUPERSCRIPTXSIZE, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2SuperscriptYSize(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEOS2SUPERSCRIPTYSIZE, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2SuperscriptXOffset(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEOS2SUPERSCRIPTXOFFSET, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2SuperscriptYOffset(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEOS2SUPERSCRIPTYOFFSET, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2StrikeoutSize(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEOS2STRIKEOUTSIZE, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeOS2StrikeoutPosition(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEOS2STRIKEOUTPOSITION, Some(0)).unwrap()
  }
  /// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#opentype-vhea-table-fields
  #[inline]
  pub fn openTypeVheaVertTypoAscender(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_OPENTYPEVHEAVERTTYPOASCENDER, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn openTypeVheaVertTypoDescender(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_OPENTYPEVHEAVERTTYPODESCENDER, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn openTypeVheaVertTypoLineGap(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_OPENTYPEVHEAVERTTYPOLINEGAP, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn openTypeVheaCaretSlopeRise(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEVHEACARETSLOPERISE, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeVheaCaretSlopeRun(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEVHEACARETSLOPERUN, Some(0)).unwrap()
  }
  #[inline]
  pub fn openTypeVheaCaretOffset(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_OPENTYPEVHEACARETOFFSET, Some(0)).unwrap()
  }
  /// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#postscript-specific-data
  #[inline]
  pub fn postscriptFontName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_POSTSCRIPTFONTNAME, None)
  }
  #[inline]
  pub fn postscriptFullName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_POSTSCRIPTFULLNAME, None)
  }
  #[inline]
  pub fn postscriptSlantAngle(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_POSTSCRIPTSLANTANGLE, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn postscriptUniqueID(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_POSTSCRIPTUNIQUEID, Some(0)).unwrap()
  }
  #[inline]
  pub fn postscriptUnderlineThickness(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_POSTSCRIPTUNDERLINETHICKNESS, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn postscriptUnderlinePosition(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_POSTSCRIPTUNDERLINEPOSITION, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn postscriptIsFixedPitch(&self) -> bool {
    self._tab.get::<bool>(FontInfo::VT_POSTSCRIPTISFIXEDPITCH, Some(false)).unwrap()
  }
  #[inline]
  pub fn postscriptBlueValues(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(FontInfo::VT_POSTSCRIPTBLUEVALUES, None)
  }
  #[inline]
  pub fn postscriptOtherBlues(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(FontInfo::VT_POSTSCRIPTOTHERBLUES, None)
  }
  #[inline]
  pub fn postscriptFamilyBlues(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(FontInfo::VT_POSTSCRIPTFAMILYBLUES, None)
  }
  #[inline]
  pub fn postscriptFamilyOtherBlues(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(FontInfo::VT_POSTSCRIPTFAMILYOTHERBLUES, None)
  }
  #[inline]
  pub fn postscriptStemSnapH(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(FontInfo::VT_POSTSCRIPTSTEMSNAPH, None)
  }
  #[inline]
  pub fn postscriptStemSnapV(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(FontInfo::VT_POSTSCRIPTSTEMSNAPV, None)
  }
  #[inline]
  pub fn postscriptBlueFuzz(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_POSTSCRIPTBLUEFUZZ, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn postscriptBlueShift(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_POSTSCRIPTBLUESHIFT, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn postscriptBlueScale(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_POSTSCRIPTBLUESCALE, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn postscriptForceBold(&self) -> bool {
    self._tab.get::<bool>(FontInfo::VT_POSTSCRIPTFORCEBOLD, Some(false)).unwrap()
  }
  #[inline]
  pub fn postscriptDefaultWidthX(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_POSTSCRIPTDEFAULTWIDTHX, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn postscriptNominalWidthX(&self) -> f32 {
    self._tab.get::<f32>(FontInfo::VT_POSTSCRIPTNOMINALWIDTHX, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn postscriptWeightName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_POSTSCRIPTWEIGHTNAME, None)
  }
  #[inline]
  pub fn postscriptDefaultCharacter(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_POSTSCRIPTDEFAULTCHARACTER, None)
  }
  #[inline]
  pub fn postscriptWindowsCharacterSet(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_POSTSCRIPTWINDOWSCHARACTERSET, Some(0)).unwrap()
  }
  /// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#macintosh-fond-resource-data
  #[inline]
  pub fn macintoshFONDFamilyID(&self) -> i32 {
    self._tab.get::<i32>(FontInfo::VT_MACINTOSHFONDFAMILYID, Some(0)).unwrap()
  }
  #[inline]
  pub fn macintoshFONDName(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FontInfo::VT_MACINTOSHFONDNAME, None)
  }
  /// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#woff-data
  #[inline]
  pub fn woffMajorVersion(&self) -> u32 {
    self._tab.get::<u32>(FontInfo::VT_WOFFMAJORVERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn woffMinorVersion(&self) -> u32 {
    self._tab.get::<u32>(FontInfo::VT_WOFFMINORVERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn woffMetadataUniqueID(&self) -> Option<WoffMetadataUniqueID<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WoffMetadataUniqueID>>(FontInfo::VT_WOFFMETADATAUNIQUEID, None)
  }
  #[inline]
  pub fn woffMetadataVendor(&self) -> Option<WoffMetadataVendor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WoffMetadataVendor>>(FontInfo::VT_WOFFMETADATAVENDOR, None)
  }
  #[inline]
  pub fn woffMetadataCredits(&self) -> Option<WoffMetadataCredits<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WoffMetadataCredits>>(FontInfo::VT_WOFFMETADATACREDITS, None)
  }
  #[inline]
  pub fn woffMetadataDescription(&self) -> Option<WoffMetadataDescription<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WoffMetadataDescription>>(FontInfo::VT_WOFFMETADATADESCRIPTION, None)
  }
  #[inline]
  pub fn woffMetadataLicense(&self) -> Option<WoffMetadataLicense<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WoffMetadataLicense>>(FontInfo::VT_WOFFMETADATALICENSE, None)
  }
  #[inline]
  pub fn woffMetadataCopyright(&self) -> Option<WoffMetadataCopyright<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WoffMetadataCopyright>>(FontInfo::VT_WOFFMETADATACOPYRIGHT, None)
  }
  #[inline]
  pub fn woffMetadataTrademark(&self) -> Option<WoffMetadataTrademark<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WoffMetadataTrademark>>(FontInfo::VT_WOFFMETADATATRADEMARK, None)
  }
  #[inline]
  pub fn woffMetadataLicensee(&self) -> Option<WoffMetadataLicensee<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<WoffMetadataLicensee>>(FontInfo::VT_WOFFMETADATALICENSEE, None)
  }
  #[inline]
  pub fn woffMetadataExtensions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtension<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtension>>>>(FontInfo::VT_WOFFMETADATAEXTENSIONS, None)
  }
  /// https://unifiedfontobject.org/versions/ufo3/fontinfo.plist/#guidelines
  #[inline]
  pub fn guidelines(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Guildeline<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Guildeline>>>>(FontInfo::VT_GUIDELINES, None)
  }
}

impl flatbuffers::Verifiable for FontInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"familyName", Self::VT_FAMILYNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"styleName", Self::VT_STYLENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"styleMapFamilyName", Self::VT_STYLEMAPFAMILYNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"styleMapStyleName", Self::VT_STYLEMAPSTYLENAME, false)?
     .visit_field::<i32>(&"versionMajor", Self::VT_VERSIONMAJOR, false)?
     .visit_field::<u32>(&"versionMinor", Self::VT_VERSIONMINOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"copyright", Self::VT_COPYRIGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"trademark", Self::VT_TRADEMARK, false)?
     .visit_field::<f32>(&"unitsPerEm", Self::VT_UNITSPEREM, false)?
     .visit_field::<f32>(&"descender", Self::VT_DESCENDER, false)?
     .visit_field::<f32>(&"xHeight", Self::VT_XHEIGHT, false)?
     .visit_field::<f32>(&"capHeight", Self::VT_CAPHEIGHT, false)?
     .visit_field::<f32>(&"ascender", Self::VT_ASCENDER, false)?
     .visit_field::<f32>(&"italicAngle", Self::VT_ITALICANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"note", Self::VT_NOTE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OpenTypeGaspRangeRecord>>>>(&"openTypeGaspRangeRecords", Self::VT_OPENTYPEGASPRANGERECORDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeHeadCreated", Self::VT_OPENTYPEHEADCREATED, false)?
     .visit_field::<u32>(&"openTypeHeadLowestRecPPEM", Self::VT_OPENTYPEHEADLOWESTRECPPEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"openTypeHeadFlags", Self::VT_OPENTYPEHEADFLAGS, false)?
     .visit_field::<i32>(&"openTypeHheaAscender", Self::VT_OPENTYPEHHEAASCENDER, false)?
     .visit_field::<i32>(&"openTypeHheaDescender", Self::VT_OPENTYPEHHEADESCENDER, false)?
     .visit_field::<i32>(&"openTypeHheaLineGap", Self::VT_OPENTYPEHHEALINEGAP, false)?
     .visit_field::<i32>(&"openTypeHheaCaretSlopeRise", Self::VT_OPENTYPEHHEACARETSLOPERISE, false)?
     .visit_field::<i32>(&"openTypeHheaCaretSlopeRun", Self::VT_OPENTYPEHHEACARETSLOPERUN, false)?
     .visit_field::<i32>(&"openTypeHheaCaretOffset", Self::VT_OPENTYPEHHEACARETOFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNameDesigner", Self::VT_OPENTYPENAMEDESIGNER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNameDesignerURL", Self::VT_OPENTYPENAMEDESIGNERURL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNameManufacturer", Self::VT_OPENTYPENAMEMANUFACTURER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNameManufacturerURL", Self::VT_OPENTYPENAMEMANUFACTURERURL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNameLicense", Self::VT_OPENTYPENAMELICENSE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNameLicenseURL", Self::VT_OPENTYPENAMELICENSEURL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNameVersion", Self::VT_OPENTYPENAMEVERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNameUniqueID", Self::VT_OPENTYPENAMEUNIQUEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNameDescription", Self::VT_OPENTYPENAMEDESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNamePreferredFamilyName", Self::VT_OPENTYPENAMEPREFERREDFAMILYNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNamePreferredSubfamilyName", Self::VT_OPENTYPENAMEPREFERREDSUBFAMILYNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNameCompatibleFullName", Self::VT_OPENTYPENAMECOMPATIBLEFULLNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNameSampleText", Self::VT_OPENTYPENAMESAMPLETEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNameWWSFamilyName", Self::VT_OPENTYPENAMEWWSFAMILYNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeNameWWSSubfamilyName", Self::VT_OPENTYPENAMEWWSSUBFAMILYNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OpenTypeNameRecord>>>>(&"openTypeNameRecords", Self::VT_OPENTYPENAMERECORDS, false)?
     .visit_field::<u32>(&"openTypeOS2WidthClass", Self::VT_OPENTYPEOS2WIDTHCLASS, false)?
     .visit_field::<u32>(&"openTypeOS2WeightClass", Self::VT_OPENTYPEOS2WEIGHTCLASS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"openTypeOS2Selection", Self::VT_OPENTYPEOS2SELECTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"openTypeOS2VendorID", Self::VT_OPENTYPEOS2VENDORID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"openTypeOS2Panose", Self::VT_OPENTYPEOS2PANOSE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"openTypeOS2FamilyClass", Self::VT_OPENTYPEOS2FAMILYCLASS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"openTypeOS2UnicodeRanges", Self::VT_OPENTYPEOS2UNICODERANGES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"openTypeOS2CodePageRanges", Self::VT_OPENTYPEOS2CODEPAGERANGES, false)?
     .visit_field::<i32>(&"openTypeOS2TypoAscender", Self::VT_OPENTYPEOS2TYPOASCENDER, false)?
     .visit_field::<i32>(&"openTypeOS2TypoDescender", Self::VT_OPENTYPEOS2TYPODESCENDER, false)?
     .visit_field::<i32>(&"openTypeOS2TypoLineGap", Self::VT_OPENTYPEOS2TYPOLINEGAP, false)?
     .visit_field::<u32>(&"openTypeOS2WinAscent", Self::VT_OPENTYPEOS2WINASCENT, false)?
     .visit_field::<u32>(&"openTypeOS2WinDescent", Self::VT_OPENTYPEOS2WINDESCENT, false)?
     .visit_field::<i32>(&"openTypeOS2SubscriptXSize", Self::VT_OPENTYPEOS2SUBSCRIPTXSIZE, false)?
     .visit_field::<i32>(&"openTypeOS2SubscriptYSize", Self::VT_OPENTYPEOS2SUBSCRIPTYSIZE, false)?
     .visit_field::<i32>(&"openTypeOS2SubscriptXOffset", Self::VT_OPENTYPEOS2SUBSCRIPTXOFFSET, false)?
     .visit_field::<i32>(&"openTypeOS2SubscriptYOffset", Self::VT_OPENTYPEOS2SUBSCRIPTYOFFSET, false)?
     .visit_field::<i32>(&"openTypeOS2SuperscriptXSize", Self::VT_OPENTYPEOS2SUPERSCRIPTXSIZE, false)?
     .visit_field::<i32>(&"openTypeOS2SuperscriptYSize", Self::VT_OPENTYPEOS2SUPERSCRIPTYSIZE, false)?
     .visit_field::<i32>(&"openTypeOS2SuperscriptXOffset", Self::VT_OPENTYPEOS2SUPERSCRIPTXOFFSET, false)?
     .visit_field::<i32>(&"openTypeOS2SuperscriptYOffset", Self::VT_OPENTYPEOS2SUPERSCRIPTYOFFSET, false)?
     .visit_field::<i32>(&"openTypeOS2StrikeoutSize", Self::VT_OPENTYPEOS2STRIKEOUTSIZE, false)?
     .visit_field::<i32>(&"openTypeOS2StrikeoutPosition", Self::VT_OPENTYPEOS2STRIKEOUTPOSITION, false)?
     .visit_field::<f32>(&"openTypeVheaVertTypoAscender", Self::VT_OPENTYPEVHEAVERTTYPOASCENDER, false)?
     .visit_field::<f32>(&"openTypeVheaVertTypoDescender", Self::VT_OPENTYPEVHEAVERTTYPODESCENDER, false)?
     .visit_field::<f32>(&"openTypeVheaVertTypoLineGap", Self::VT_OPENTYPEVHEAVERTTYPOLINEGAP, false)?
     .visit_field::<i32>(&"openTypeVheaCaretSlopeRise", Self::VT_OPENTYPEVHEACARETSLOPERISE, false)?
     .visit_field::<i32>(&"openTypeVheaCaretSlopeRun", Self::VT_OPENTYPEVHEACARETSLOPERUN, false)?
     .visit_field::<i32>(&"openTypeVheaCaretOffset", Self::VT_OPENTYPEVHEACARETOFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"postscriptFontName", Self::VT_POSTSCRIPTFONTNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"postscriptFullName", Self::VT_POSTSCRIPTFULLNAME, false)?
     .visit_field::<f32>(&"postscriptSlantAngle", Self::VT_POSTSCRIPTSLANTANGLE, false)?
     .visit_field::<i32>(&"postscriptUniqueID", Self::VT_POSTSCRIPTUNIQUEID, false)?
     .visit_field::<f32>(&"postscriptUnderlineThickness", Self::VT_POSTSCRIPTUNDERLINETHICKNESS, false)?
     .visit_field::<f32>(&"postscriptUnderlinePosition", Self::VT_POSTSCRIPTUNDERLINEPOSITION, false)?
     .visit_field::<bool>(&"postscriptIsFixedPitch", Self::VT_POSTSCRIPTISFIXEDPITCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(&"postscriptBlueValues", Self::VT_POSTSCRIPTBLUEVALUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(&"postscriptOtherBlues", Self::VT_POSTSCRIPTOTHERBLUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(&"postscriptFamilyBlues", Self::VT_POSTSCRIPTFAMILYBLUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(&"postscriptFamilyOtherBlues", Self::VT_POSTSCRIPTFAMILYOTHERBLUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(&"postscriptStemSnapH", Self::VT_POSTSCRIPTSTEMSNAPH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(&"postscriptStemSnapV", Self::VT_POSTSCRIPTSTEMSNAPV, false)?
     .visit_field::<f32>(&"postscriptBlueFuzz", Self::VT_POSTSCRIPTBLUEFUZZ, false)?
     .visit_field::<f32>(&"postscriptBlueShift", Self::VT_POSTSCRIPTBLUESHIFT, false)?
     .visit_field::<f32>(&"postscriptBlueScale", Self::VT_POSTSCRIPTBLUESCALE, false)?
     .visit_field::<bool>(&"postscriptForceBold", Self::VT_POSTSCRIPTFORCEBOLD, false)?
     .visit_field::<f32>(&"postscriptDefaultWidthX", Self::VT_POSTSCRIPTDEFAULTWIDTHX, false)?
     .visit_field::<f32>(&"postscriptNominalWidthX", Self::VT_POSTSCRIPTNOMINALWIDTHX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"postscriptWeightName", Self::VT_POSTSCRIPTWEIGHTNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"postscriptDefaultCharacter", Self::VT_POSTSCRIPTDEFAULTCHARACTER, false)?
     .visit_field::<i32>(&"postscriptWindowsCharacterSet", Self::VT_POSTSCRIPTWINDOWSCHARACTERSET, false)?
     .visit_field::<i32>(&"macintoshFONDFamilyID", Self::VT_MACINTOSHFONDFAMILYID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"macintoshFONDName", Self::VT_MACINTOSHFONDNAME, false)?
     .visit_field::<u32>(&"woffMajorVersion", Self::VT_WOFFMAJORVERSION, false)?
     .visit_field::<u32>(&"woffMinorVersion", Self::VT_WOFFMINORVERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<WoffMetadataUniqueID>>(&"woffMetadataUniqueID", Self::VT_WOFFMETADATAUNIQUEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<WoffMetadataVendor>>(&"woffMetadataVendor", Self::VT_WOFFMETADATAVENDOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<WoffMetadataCredits>>(&"woffMetadataCredits", Self::VT_WOFFMETADATACREDITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<WoffMetadataDescription>>(&"woffMetadataDescription", Self::VT_WOFFMETADATADESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<WoffMetadataLicense>>(&"woffMetadataLicense", Self::VT_WOFFMETADATALICENSE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<WoffMetadataCopyright>>(&"woffMetadataCopyright", Self::VT_WOFFMETADATACOPYRIGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<WoffMetadataTrademark>>(&"woffMetadataTrademark", Self::VT_WOFFMETADATATRADEMARK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<WoffMetadataLicensee>>(&"woffMetadataLicensee", Self::VT_WOFFMETADATALICENSEE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WoffMetadataExtension>>>>(&"woffMetadataExtensions", Self::VT_WOFFMETADATAEXTENSIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Guildeline>>>>(&"guidelines", Self::VT_GUIDELINES, false)?
     .finish();
    Ok(())
  }
}
pub struct FontInfoArgs<'a> {
    pub familyName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub styleName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub styleMapFamilyName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub styleMapStyleName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub versionMajor: i32,
    pub versionMinor: u32,
    pub copyright: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trademark: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unitsPerEm: f32,
    pub descender: f32,
    pub xHeight: f32,
    pub capHeight: f32,
    pub ascender: f32,
    pub italicAngle: f32,
    pub note: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeGaspRangeRecords: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OpenTypeGaspRangeRecord<'a>>>>>,
    pub openTypeHeadCreated: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeHeadLowestRecPPEM: u32,
    pub openTypeHeadFlags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub openTypeHheaAscender: i32,
    pub openTypeHheaDescender: i32,
    pub openTypeHheaLineGap: i32,
    pub openTypeHheaCaretSlopeRise: i32,
    pub openTypeHheaCaretSlopeRun: i32,
    pub openTypeHheaCaretOffset: i32,
    pub openTypeNameDesigner: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNameDesignerURL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNameManufacturer: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNameManufacturerURL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNameLicense: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNameLicenseURL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNameVersion: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNameUniqueID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNameDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNamePreferredFamilyName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNamePreferredSubfamilyName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNameCompatibleFullName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNameSampleText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNameWWSFamilyName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNameWWSSubfamilyName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeNameRecords: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OpenTypeNameRecord<'a>>>>>,
    pub openTypeOS2WidthClass: u32,
    pub openTypeOS2WeightClass: u32,
    pub openTypeOS2Selection: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub openTypeOS2VendorID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub openTypeOS2Panose: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub openTypeOS2FamilyClass: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub openTypeOS2UnicodeRanges: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub openTypeOS2CodePageRanges: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub openTypeOS2TypoAscender: i32,
    pub openTypeOS2TypoDescender: i32,
    pub openTypeOS2TypoLineGap: i32,
    pub openTypeOS2WinAscent: u32,
    pub openTypeOS2WinDescent: u32,
    pub openTypeOS2SubscriptXSize: i32,
    pub openTypeOS2SubscriptYSize: i32,
    pub openTypeOS2SubscriptXOffset: i32,
    pub openTypeOS2SubscriptYOffset: i32,
    pub openTypeOS2SuperscriptXSize: i32,
    pub openTypeOS2SuperscriptYSize: i32,
    pub openTypeOS2SuperscriptXOffset: i32,
    pub openTypeOS2SuperscriptYOffset: i32,
    pub openTypeOS2StrikeoutSize: i32,
    pub openTypeOS2StrikeoutPosition: i32,
    pub openTypeVheaVertTypoAscender: f32,
    pub openTypeVheaVertTypoDescender: f32,
    pub openTypeVheaVertTypoLineGap: f32,
    pub openTypeVheaCaretSlopeRise: i32,
    pub openTypeVheaCaretSlopeRun: i32,
    pub openTypeVheaCaretOffset: i32,
    pub postscriptFontName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub postscriptFullName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub postscriptSlantAngle: f32,
    pub postscriptUniqueID: i32,
    pub postscriptUnderlineThickness: f32,
    pub postscriptUnderlinePosition: f32,
    pub postscriptIsFixedPitch: bool,
    pub postscriptBlueValues: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub postscriptOtherBlues: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub postscriptFamilyBlues: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub postscriptFamilyOtherBlues: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub postscriptStemSnapH: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub postscriptStemSnapV: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub postscriptBlueFuzz: f32,
    pub postscriptBlueShift: f32,
    pub postscriptBlueScale: f32,
    pub postscriptForceBold: bool,
    pub postscriptDefaultWidthX: f32,
    pub postscriptNominalWidthX: f32,
    pub postscriptWeightName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub postscriptDefaultCharacter: Option<flatbuffers::WIPOffset<&'a str>>,
    pub postscriptWindowsCharacterSet: i32,
    pub macintoshFONDFamilyID: i32,
    pub macintoshFONDName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub woffMajorVersion: u32,
    pub woffMinorVersion: u32,
    pub woffMetadataUniqueID: Option<flatbuffers::WIPOffset<WoffMetadataUniqueID<'a>>>,
    pub woffMetadataVendor: Option<flatbuffers::WIPOffset<WoffMetadataVendor<'a>>>,
    pub woffMetadataCredits: Option<flatbuffers::WIPOffset<WoffMetadataCredits<'a>>>,
    pub woffMetadataDescription: Option<flatbuffers::WIPOffset<WoffMetadataDescription<'a>>>,
    pub woffMetadataLicense: Option<flatbuffers::WIPOffset<WoffMetadataLicense<'a>>>,
    pub woffMetadataCopyright: Option<flatbuffers::WIPOffset<WoffMetadataCopyright<'a>>>,
    pub woffMetadataTrademark: Option<flatbuffers::WIPOffset<WoffMetadataTrademark<'a>>>,
    pub woffMetadataLicensee: Option<flatbuffers::WIPOffset<WoffMetadataLicensee<'a>>>,
    pub woffMetadataExtensions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtension<'a>>>>>,
    pub guidelines: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Guildeline<'a>>>>>,
}
impl<'a> Default for FontInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        FontInfoArgs {
            familyName: None,
            styleName: None,
            styleMapFamilyName: None,
            styleMapStyleName: None,
            versionMajor: 0,
            versionMinor: 0,
            copyright: None,
            trademark: None,
            unitsPerEm: 0.0,
            descender: 0.0,
            xHeight: 0.0,
            capHeight: 0.0,
            ascender: 0.0,
            italicAngle: 0.0,
            note: None,
            openTypeGaspRangeRecords: None,
            openTypeHeadCreated: None,
            openTypeHeadLowestRecPPEM: 0,
            openTypeHeadFlags: None,
            openTypeHheaAscender: 0,
            openTypeHheaDescender: 0,
            openTypeHheaLineGap: 0,
            openTypeHheaCaretSlopeRise: 0,
            openTypeHheaCaretSlopeRun: 0,
            openTypeHheaCaretOffset: 0,
            openTypeNameDesigner: None,
            openTypeNameDesignerURL: None,
            openTypeNameManufacturer: None,
            openTypeNameManufacturerURL: None,
            openTypeNameLicense: None,
            openTypeNameLicenseURL: None,
            openTypeNameVersion: None,
            openTypeNameUniqueID: None,
            openTypeNameDescription: None,
            openTypeNamePreferredFamilyName: None,
            openTypeNamePreferredSubfamilyName: None,
            openTypeNameCompatibleFullName: None,
            openTypeNameSampleText: None,
            openTypeNameWWSFamilyName: None,
            openTypeNameWWSSubfamilyName: None,
            openTypeNameRecords: None,
            openTypeOS2WidthClass: 0,
            openTypeOS2WeightClass: 0,
            openTypeOS2Selection: None,
            openTypeOS2VendorID: None,
            openTypeOS2Panose: None,
            openTypeOS2FamilyClass: None,
            openTypeOS2UnicodeRanges: None,
            openTypeOS2CodePageRanges: None,
            openTypeOS2TypoAscender: 0,
            openTypeOS2TypoDescender: 0,
            openTypeOS2TypoLineGap: 0,
            openTypeOS2WinAscent: 0,
            openTypeOS2WinDescent: 0,
            openTypeOS2SubscriptXSize: 0,
            openTypeOS2SubscriptYSize: 0,
            openTypeOS2SubscriptXOffset: 0,
            openTypeOS2SubscriptYOffset: 0,
            openTypeOS2SuperscriptXSize: 0,
            openTypeOS2SuperscriptYSize: 0,
            openTypeOS2SuperscriptXOffset: 0,
            openTypeOS2SuperscriptYOffset: 0,
            openTypeOS2StrikeoutSize: 0,
            openTypeOS2StrikeoutPosition: 0,
            openTypeVheaVertTypoAscender: 0.0,
            openTypeVheaVertTypoDescender: 0.0,
            openTypeVheaVertTypoLineGap: 0.0,
            openTypeVheaCaretSlopeRise: 0,
            openTypeVheaCaretSlopeRun: 0,
            openTypeVheaCaretOffset: 0,
            postscriptFontName: None,
            postscriptFullName: None,
            postscriptSlantAngle: 0.0,
            postscriptUniqueID: 0,
            postscriptUnderlineThickness: 0.0,
            postscriptUnderlinePosition: 0.0,
            postscriptIsFixedPitch: false,
            postscriptBlueValues: None,
            postscriptOtherBlues: None,
            postscriptFamilyBlues: None,
            postscriptFamilyOtherBlues: None,
            postscriptStemSnapH: None,
            postscriptStemSnapV: None,
            postscriptBlueFuzz: 0.0,
            postscriptBlueShift: 0.0,
            postscriptBlueScale: 0.0,
            postscriptForceBold: false,
            postscriptDefaultWidthX: 0.0,
            postscriptNominalWidthX: 0.0,
            postscriptWeightName: None,
            postscriptDefaultCharacter: None,
            postscriptWindowsCharacterSet: 0,
            macintoshFONDFamilyID: 0,
            macintoshFONDName: None,
            woffMajorVersion: 0,
            woffMinorVersion: 0,
            woffMetadataUniqueID: None,
            woffMetadataVendor: None,
            woffMetadataCredits: None,
            woffMetadataDescription: None,
            woffMetadataLicense: None,
            woffMetadataCopyright: None,
            woffMetadataTrademark: None,
            woffMetadataLicensee: None,
            woffMetadataExtensions: None,
            guidelines: None,
        }
    }
}
pub struct FontInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FontInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_familyName(&mut self, familyName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_FAMILYNAME, familyName);
  }
  #[inline]
  pub fn add_styleName(&mut self, styleName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_STYLENAME, styleName);
  }
  #[inline]
  pub fn add_styleMapFamilyName(&mut self, styleMapFamilyName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_STYLEMAPFAMILYNAME, styleMapFamilyName);
  }
  #[inline]
  pub fn add_styleMapStyleName(&mut self, styleMapStyleName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_STYLEMAPSTYLENAME, styleMapStyleName);
  }
  #[inline]
  pub fn add_versionMajor(&mut self, versionMajor: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_VERSIONMAJOR, versionMajor, 0);
  }
  #[inline]
  pub fn add_versionMinor(&mut self, versionMinor: u32) {
    self.fbb_.push_slot::<u32>(FontInfo::VT_VERSIONMINOR, versionMinor, 0);
  }
  #[inline]
  pub fn add_copyright(&mut self, copyright: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_COPYRIGHT, copyright);
  }
  #[inline]
  pub fn add_trademark(&mut self, trademark: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_TRADEMARK, trademark);
  }
  #[inline]
  pub fn add_unitsPerEm(&mut self, unitsPerEm: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_UNITSPEREM, unitsPerEm, 0.0);
  }
  #[inline]
  pub fn add_descender(&mut self, descender: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_DESCENDER, descender, 0.0);
  }
  #[inline]
  pub fn add_xHeight(&mut self, xHeight: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_XHEIGHT, xHeight, 0.0);
  }
  #[inline]
  pub fn add_capHeight(&mut self, capHeight: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_CAPHEIGHT, capHeight, 0.0);
  }
  #[inline]
  pub fn add_ascender(&mut self, ascender: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_ASCENDER, ascender, 0.0);
  }
  #[inline]
  pub fn add_italicAngle(&mut self, italicAngle: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_ITALICANGLE, italicAngle, 0.0);
  }
  #[inline]
  pub fn add_note(&mut self, note: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_NOTE, note);
  }
  #[inline]
  pub fn add_openTypeGaspRangeRecords(&mut self, openTypeGaspRangeRecords: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OpenTypeGaspRangeRecord<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPEGASPRANGERECORDS, openTypeGaspRangeRecords);
  }
  #[inline]
  pub fn add_openTypeHeadCreated(&mut self, openTypeHeadCreated: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPEHEADCREATED, openTypeHeadCreated);
  }
  #[inline]
  pub fn add_openTypeHeadLowestRecPPEM(&mut self, openTypeHeadLowestRecPPEM: u32) {
    self.fbb_.push_slot::<u32>(FontInfo::VT_OPENTYPEHEADLOWESTRECPPEM, openTypeHeadLowestRecPPEM, 0);
  }
  #[inline]
  pub fn add_openTypeHeadFlags(&mut self, openTypeHeadFlags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPEHEADFLAGS, openTypeHeadFlags);
  }
  #[inline]
  pub fn add_openTypeHheaAscender(&mut self, openTypeHheaAscender: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEHHEAASCENDER, openTypeHheaAscender, 0);
  }
  #[inline]
  pub fn add_openTypeHheaDescender(&mut self, openTypeHheaDescender: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEHHEADESCENDER, openTypeHheaDescender, 0);
  }
  #[inline]
  pub fn add_openTypeHheaLineGap(&mut self, openTypeHheaLineGap: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEHHEALINEGAP, openTypeHheaLineGap, 0);
  }
  #[inline]
  pub fn add_openTypeHheaCaretSlopeRise(&mut self, openTypeHheaCaretSlopeRise: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEHHEACARETSLOPERISE, openTypeHheaCaretSlopeRise, 0);
  }
  #[inline]
  pub fn add_openTypeHheaCaretSlopeRun(&mut self, openTypeHheaCaretSlopeRun: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEHHEACARETSLOPERUN, openTypeHheaCaretSlopeRun, 0);
  }
  #[inline]
  pub fn add_openTypeHheaCaretOffset(&mut self, openTypeHheaCaretOffset: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEHHEACARETOFFSET, openTypeHheaCaretOffset, 0);
  }
  #[inline]
  pub fn add_openTypeNameDesigner(&mut self, openTypeNameDesigner: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMEDESIGNER, openTypeNameDesigner);
  }
  #[inline]
  pub fn add_openTypeNameDesignerURL(&mut self, openTypeNameDesignerURL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMEDESIGNERURL, openTypeNameDesignerURL);
  }
  #[inline]
  pub fn add_openTypeNameManufacturer(&mut self, openTypeNameManufacturer: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMEMANUFACTURER, openTypeNameManufacturer);
  }
  #[inline]
  pub fn add_openTypeNameManufacturerURL(&mut self, openTypeNameManufacturerURL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMEMANUFACTURERURL, openTypeNameManufacturerURL);
  }
  #[inline]
  pub fn add_openTypeNameLicense(&mut self, openTypeNameLicense: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMELICENSE, openTypeNameLicense);
  }
  #[inline]
  pub fn add_openTypeNameLicenseURL(&mut self, openTypeNameLicenseURL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMELICENSEURL, openTypeNameLicenseURL);
  }
  #[inline]
  pub fn add_openTypeNameVersion(&mut self, openTypeNameVersion: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMEVERSION, openTypeNameVersion);
  }
  #[inline]
  pub fn add_openTypeNameUniqueID(&mut self, openTypeNameUniqueID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMEUNIQUEID, openTypeNameUniqueID);
  }
  #[inline]
  pub fn add_openTypeNameDescription(&mut self, openTypeNameDescription: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMEDESCRIPTION, openTypeNameDescription);
  }
  #[inline]
  pub fn add_openTypeNamePreferredFamilyName(&mut self, openTypeNamePreferredFamilyName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMEPREFERREDFAMILYNAME, openTypeNamePreferredFamilyName);
  }
  #[inline]
  pub fn add_openTypeNamePreferredSubfamilyName(&mut self, openTypeNamePreferredSubfamilyName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMEPREFERREDSUBFAMILYNAME, openTypeNamePreferredSubfamilyName);
  }
  #[inline]
  pub fn add_openTypeNameCompatibleFullName(&mut self, openTypeNameCompatibleFullName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMECOMPATIBLEFULLNAME, openTypeNameCompatibleFullName);
  }
  #[inline]
  pub fn add_openTypeNameSampleText(&mut self, openTypeNameSampleText: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMESAMPLETEXT, openTypeNameSampleText);
  }
  #[inline]
  pub fn add_openTypeNameWWSFamilyName(&mut self, openTypeNameWWSFamilyName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMEWWSFAMILYNAME, openTypeNameWWSFamilyName);
  }
  #[inline]
  pub fn add_openTypeNameWWSSubfamilyName(&mut self, openTypeNameWWSSubfamilyName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMEWWSSUBFAMILYNAME, openTypeNameWWSSubfamilyName);
  }
  #[inline]
  pub fn add_openTypeNameRecords(&mut self, openTypeNameRecords: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OpenTypeNameRecord<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPENAMERECORDS, openTypeNameRecords);
  }
  #[inline]
  pub fn add_openTypeOS2WidthClass(&mut self, openTypeOS2WidthClass: u32) {
    self.fbb_.push_slot::<u32>(FontInfo::VT_OPENTYPEOS2WIDTHCLASS, openTypeOS2WidthClass, 0);
  }
  #[inline]
  pub fn add_openTypeOS2WeightClass(&mut self, openTypeOS2WeightClass: u32) {
    self.fbb_.push_slot::<u32>(FontInfo::VT_OPENTYPEOS2WEIGHTCLASS, openTypeOS2WeightClass, 0);
  }
  #[inline]
  pub fn add_openTypeOS2Selection(&mut self, openTypeOS2Selection: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPEOS2SELECTION, openTypeOS2Selection);
  }
  #[inline]
  pub fn add_openTypeOS2VendorID(&mut self, openTypeOS2VendorID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPEOS2VENDORID, openTypeOS2VendorID);
  }
  #[inline]
  pub fn add_openTypeOS2Panose(&mut self, openTypeOS2Panose: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPEOS2PANOSE, openTypeOS2Panose);
  }
  #[inline]
  pub fn add_openTypeOS2FamilyClass(&mut self, openTypeOS2FamilyClass: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPEOS2FAMILYCLASS, openTypeOS2FamilyClass);
  }
  #[inline]
  pub fn add_openTypeOS2UnicodeRanges(&mut self, openTypeOS2UnicodeRanges: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPEOS2UNICODERANGES, openTypeOS2UnicodeRanges);
  }
  #[inline]
  pub fn add_openTypeOS2CodePageRanges(&mut self, openTypeOS2CodePageRanges: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_OPENTYPEOS2CODEPAGERANGES, openTypeOS2CodePageRanges);
  }
  #[inline]
  pub fn add_openTypeOS2TypoAscender(&mut self, openTypeOS2TypoAscender: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEOS2TYPOASCENDER, openTypeOS2TypoAscender, 0);
  }
  #[inline]
  pub fn add_openTypeOS2TypoDescender(&mut self, openTypeOS2TypoDescender: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEOS2TYPODESCENDER, openTypeOS2TypoDescender, 0);
  }
  #[inline]
  pub fn add_openTypeOS2TypoLineGap(&mut self, openTypeOS2TypoLineGap: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEOS2TYPOLINEGAP, openTypeOS2TypoLineGap, 0);
  }
  #[inline]
  pub fn add_openTypeOS2WinAscent(&mut self, openTypeOS2WinAscent: u32) {
    self.fbb_.push_slot::<u32>(FontInfo::VT_OPENTYPEOS2WINASCENT, openTypeOS2WinAscent, 0);
  }
  #[inline]
  pub fn add_openTypeOS2WinDescent(&mut self, openTypeOS2WinDescent: u32) {
    self.fbb_.push_slot::<u32>(FontInfo::VT_OPENTYPEOS2WINDESCENT, openTypeOS2WinDescent, 0);
  }
  #[inline]
  pub fn add_openTypeOS2SubscriptXSize(&mut self, openTypeOS2SubscriptXSize: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEOS2SUBSCRIPTXSIZE, openTypeOS2SubscriptXSize, 0);
  }
  #[inline]
  pub fn add_openTypeOS2SubscriptYSize(&mut self, openTypeOS2SubscriptYSize: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEOS2SUBSCRIPTYSIZE, openTypeOS2SubscriptYSize, 0);
  }
  #[inline]
  pub fn add_openTypeOS2SubscriptXOffset(&mut self, openTypeOS2SubscriptXOffset: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEOS2SUBSCRIPTXOFFSET, openTypeOS2SubscriptXOffset, 0);
  }
  #[inline]
  pub fn add_openTypeOS2SubscriptYOffset(&mut self, openTypeOS2SubscriptYOffset: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEOS2SUBSCRIPTYOFFSET, openTypeOS2SubscriptYOffset, 0);
  }
  #[inline]
  pub fn add_openTypeOS2SuperscriptXSize(&mut self, openTypeOS2SuperscriptXSize: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEOS2SUPERSCRIPTXSIZE, openTypeOS2SuperscriptXSize, 0);
  }
  #[inline]
  pub fn add_openTypeOS2SuperscriptYSize(&mut self, openTypeOS2SuperscriptYSize: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEOS2SUPERSCRIPTYSIZE, openTypeOS2SuperscriptYSize, 0);
  }
  #[inline]
  pub fn add_openTypeOS2SuperscriptXOffset(&mut self, openTypeOS2SuperscriptXOffset: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEOS2SUPERSCRIPTXOFFSET, openTypeOS2SuperscriptXOffset, 0);
  }
  #[inline]
  pub fn add_openTypeOS2SuperscriptYOffset(&mut self, openTypeOS2SuperscriptYOffset: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEOS2SUPERSCRIPTYOFFSET, openTypeOS2SuperscriptYOffset, 0);
  }
  #[inline]
  pub fn add_openTypeOS2StrikeoutSize(&mut self, openTypeOS2StrikeoutSize: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEOS2STRIKEOUTSIZE, openTypeOS2StrikeoutSize, 0);
  }
  #[inline]
  pub fn add_openTypeOS2StrikeoutPosition(&mut self, openTypeOS2StrikeoutPosition: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEOS2STRIKEOUTPOSITION, openTypeOS2StrikeoutPosition, 0);
  }
  #[inline]
  pub fn add_openTypeVheaVertTypoAscender(&mut self, openTypeVheaVertTypoAscender: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_OPENTYPEVHEAVERTTYPOASCENDER, openTypeVheaVertTypoAscender, 0.0);
  }
  #[inline]
  pub fn add_openTypeVheaVertTypoDescender(&mut self, openTypeVheaVertTypoDescender: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_OPENTYPEVHEAVERTTYPODESCENDER, openTypeVheaVertTypoDescender, 0.0);
  }
  #[inline]
  pub fn add_openTypeVheaVertTypoLineGap(&mut self, openTypeVheaVertTypoLineGap: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_OPENTYPEVHEAVERTTYPOLINEGAP, openTypeVheaVertTypoLineGap, 0.0);
  }
  #[inline]
  pub fn add_openTypeVheaCaretSlopeRise(&mut self, openTypeVheaCaretSlopeRise: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEVHEACARETSLOPERISE, openTypeVheaCaretSlopeRise, 0);
  }
  #[inline]
  pub fn add_openTypeVheaCaretSlopeRun(&mut self, openTypeVheaCaretSlopeRun: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEVHEACARETSLOPERUN, openTypeVheaCaretSlopeRun, 0);
  }
  #[inline]
  pub fn add_openTypeVheaCaretOffset(&mut self, openTypeVheaCaretOffset: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_OPENTYPEVHEACARETOFFSET, openTypeVheaCaretOffset, 0);
  }
  #[inline]
  pub fn add_postscriptFontName(&mut self, postscriptFontName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_POSTSCRIPTFONTNAME, postscriptFontName);
  }
  #[inline]
  pub fn add_postscriptFullName(&mut self, postscriptFullName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_POSTSCRIPTFULLNAME, postscriptFullName);
  }
  #[inline]
  pub fn add_postscriptSlantAngle(&mut self, postscriptSlantAngle: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_POSTSCRIPTSLANTANGLE, postscriptSlantAngle, 0.0);
  }
  #[inline]
  pub fn add_postscriptUniqueID(&mut self, postscriptUniqueID: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_POSTSCRIPTUNIQUEID, postscriptUniqueID, 0);
  }
  #[inline]
  pub fn add_postscriptUnderlineThickness(&mut self, postscriptUnderlineThickness: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_POSTSCRIPTUNDERLINETHICKNESS, postscriptUnderlineThickness, 0.0);
  }
  #[inline]
  pub fn add_postscriptUnderlinePosition(&mut self, postscriptUnderlinePosition: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_POSTSCRIPTUNDERLINEPOSITION, postscriptUnderlinePosition, 0.0);
  }
  #[inline]
  pub fn add_postscriptIsFixedPitch(&mut self, postscriptIsFixedPitch: bool) {
    self.fbb_.push_slot::<bool>(FontInfo::VT_POSTSCRIPTISFIXEDPITCH, postscriptIsFixedPitch, false);
  }
  #[inline]
  pub fn add_postscriptBlueValues(&mut self, postscriptBlueValues: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_POSTSCRIPTBLUEVALUES, postscriptBlueValues);
  }
  #[inline]
  pub fn add_postscriptOtherBlues(&mut self, postscriptOtherBlues: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_POSTSCRIPTOTHERBLUES, postscriptOtherBlues);
  }
  #[inline]
  pub fn add_postscriptFamilyBlues(&mut self, postscriptFamilyBlues: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_POSTSCRIPTFAMILYBLUES, postscriptFamilyBlues);
  }
  #[inline]
  pub fn add_postscriptFamilyOtherBlues(&mut self, postscriptFamilyOtherBlues: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_POSTSCRIPTFAMILYOTHERBLUES, postscriptFamilyOtherBlues);
  }
  #[inline]
  pub fn add_postscriptStemSnapH(&mut self, postscriptStemSnapH: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_POSTSCRIPTSTEMSNAPH, postscriptStemSnapH);
  }
  #[inline]
  pub fn add_postscriptStemSnapV(&mut self, postscriptStemSnapV: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_POSTSCRIPTSTEMSNAPV, postscriptStemSnapV);
  }
  #[inline]
  pub fn add_postscriptBlueFuzz(&mut self, postscriptBlueFuzz: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_POSTSCRIPTBLUEFUZZ, postscriptBlueFuzz, 0.0);
  }
  #[inline]
  pub fn add_postscriptBlueShift(&mut self, postscriptBlueShift: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_POSTSCRIPTBLUESHIFT, postscriptBlueShift, 0.0);
  }
  #[inline]
  pub fn add_postscriptBlueScale(&mut self, postscriptBlueScale: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_POSTSCRIPTBLUESCALE, postscriptBlueScale, 0.0);
  }
  #[inline]
  pub fn add_postscriptForceBold(&mut self, postscriptForceBold: bool) {
    self.fbb_.push_slot::<bool>(FontInfo::VT_POSTSCRIPTFORCEBOLD, postscriptForceBold, false);
  }
  #[inline]
  pub fn add_postscriptDefaultWidthX(&mut self, postscriptDefaultWidthX: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_POSTSCRIPTDEFAULTWIDTHX, postscriptDefaultWidthX, 0.0);
  }
  #[inline]
  pub fn add_postscriptNominalWidthX(&mut self, postscriptNominalWidthX: f32) {
    self.fbb_.push_slot::<f32>(FontInfo::VT_POSTSCRIPTNOMINALWIDTHX, postscriptNominalWidthX, 0.0);
  }
  #[inline]
  pub fn add_postscriptWeightName(&mut self, postscriptWeightName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_POSTSCRIPTWEIGHTNAME, postscriptWeightName);
  }
  #[inline]
  pub fn add_postscriptDefaultCharacter(&mut self, postscriptDefaultCharacter: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_POSTSCRIPTDEFAULTCHARACTER, postscriptDefaultCharacter);
  }
  #[inline]
  pub fn add_postscriptWindowsCharacterSet(&mut self, postscriptWindowsCharacterSet: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_POSTSCRIPTWINDOWSCHARACTERSET, postscriptWindowsCharacterSet, 0);
  }
  #[inline]
  pub fn add_macintoshFONDFamilyID(&mut self, macintoshFONDFamilyID: i32) {
    self.fbb_.push_slot::<i32>(FontInfo::VT_MACINTOSHFONDFAMILYID, macintoshFONDFamilyID, 0);
  }
  #[inline]
  pub fn add_macintoshFONDName(&mut self, macintoshFONDName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_MACINTOSHFONDNAME, macintoshFONDName);
  }
  #[inline]
  pub fn add_woffMajorVersion(&mut self, woffMajorVersion: u32) {
    self.fbb_.push_slot::<u32>(FontInfo::VT_WOFFMAJORVERSION, woffMajorVersion, 0);
  }
  #[inline]
  pub fn add_woffMinorVersion(&mut self, woffMinorVersion: u32) {
    self.fbb_.push_slot::<u32>(FontInfo::VT_WOFFMINORVERSION, woffMinorVersion, 0);
  }
  #[inline]
  pub fn add_woffMetadataUniqueID(&mut self, woffMetadataUniqueID: flatbuffers::WIPOffset<WoffMetadataUniqueID<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WoffMetadataUniqueID>>(FontInfo::VT_WOFFMETADATAUNIQUEID, woffMetadataUniqueID);
  }
  #[inline]
  pub fn add_woffMetadataVendor(&mut self, woffMetadataVendor: flatbuffers::WIPOffset<WoffMetadataVendor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WoffMetadataVendor>>(FontInfo::VT_WOFFMETADATAVENDOR, woffMetadataVendor);
  }
  #[inline]
  pub fn add_woffMetadataCredits(&mut self, woffMetadataCredits: flatbuffers::WIPOffset<WoffMetadataCredits<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WoffMetadataCredits>>(FontInfo::VT_WOFFMETADATACREDITS, woffMetadataCredits);
  }
  #[inline]
  pub fn add_woffMetadataDescription(&mut self, woffMetadataDescription: flatbuffers::WIPOffset<WoffMetadataDescription<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WoffMetadataDescription>>(FontInfo::VT_WOFFMETADATADESCRIPTION, woffMetadataDescription);
  }
  #[inline]
  pub fn add_woffMetadataLicense(&mut self, woffMetadataLicense: flatbuffers::WIPOffset<WoffMetadataLicense<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WoffMetadataLicense>>(FontInfo::VT_WOFFMETADATALICENSE, woffMetadataLicense);
  }
  #[inline]
  pub fn add_woffMetadataCopyright(&mut self, woffMetadataCopyright: flatbuffers::WIPOffset<WoffMetadataCopyright<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WoffMetadataCopyright>>(FontInfo::VT_WOFFMETADATACOPYRIGHT, woffMetadataCopyright);
  }
  #[inline]
  pub fn add_woffMetadataTrademark(&mut self, woffMetadataTrademark: flatbuffers::WIPOffset<WoffMetadataTrademark<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WoffMetadataTrademark>>(FontInfo::VT_WOFFMETADATATRADEMARK, woffMetadataTrademark);
  }
  #[inline]
  pub fn add_woffMetadataLicensee(&mut self, woffMetadataLicensee: flatbuffers::WIPOffset<WoffMetadataLicensee<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<WoffMetadataLicensee>>(FontInfo::VT_WOFFMETADATALICENSEE, woffMetadataLicensee);
  }
  #[inline]
  pub fn add_woffMetadataExtensions(&mut self, woffMetadataExtensions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WoffMetadataExtension<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_WOFFMETADATAEXTENSIONS, woffMetadataExtensions);
  }
  #[inline]
  pub fn add_guidelines(&mut self, guidelines: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Guildeline<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FontInfo::VT_GUIDELINES, guidelines);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FontInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FontInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FontInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for FontInfo<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("FontInfo");
      ds.field("familyName", &self.familyName());
      ds.field("styleName", &self.styleName());
      ds.field("styleMapFamilyName", &self.styleMapFamilyName());
      ds.field("styleMapStyleName", &self.styleMapStyleName());
      ds.field("versionMajor", &self.versionMajor());
      ds.field("versionMinor", &self.versionMinor());
      ds.field("copyright", &self.copyright());
      ds.field("trademark", &self.trademark());
      ds.field("unitsPerEm", &self.unitsPerEm());
      ds.field("descender", &self.descender());
      ds.field("xHeight", &self.xHeight());
      ds.field("capHeight", &self.capHeight());
      ds.field("ascender", &self.ascender());
      ds.field("italicAngle", &self.italicAngle());
      ds.field("note", &self.note());
      ds.field("openTypeGaspRangeRecords", &self.openTypeGaspRangeRecords());
      ds.field("openTypeHeadCreated", &self.openTypeHeadCreated());
      ds.field("openTypeHeadLowestRecPPEM", &self.openTypeHeadLowestRecPPEM());
      ds.field("openTypeHeadFlags", &self.openTypeHeadFlags());
      ds.field("openTypeHheaAscender", &self.openTypeHheaAscender());
      ds.field("openTypeHheaDescender", &self.openTypeHheaDescender());
      ds.field("openTypeHheaLineGap", &self.openTypeHheaLineGap());
      ds.field("openTypeHheaCaretSlopeRise", &self.openTypeHheaCaretSlopeRise());
      ds.field("openTypeHheaCaretSlopeRun", &self.openTypeHheaCaretSlopeRun());
      ds.field("openTypeHheaCaretOffset", &self.openTypeHheaCaretOffset());
      ds.field("openTypeNameDesigner", &self.openTypeNameDesigner());
      ds.field("openTypeNameDesignerURL", &self.openTypeNameDesignerURL());
      ds.field("openTypeNameManufacturer", &self.openTypeNameManufacturer());
      ds.field("openTypeNameManufacturerURL", &self.openTypeNameManufacturerURL());
      ds.field("openTypeNameLicense", &self.openTypeNameLicense());
      ds.field("openTypeNameLicenseURL", &self.openTypeNameLicenseURL());
      ds.field("openTypeNameVersion", &self.openTypeNameVersion());
      ds.field("openTypeNameUniqueID", &self.openTypeNameUniqueID());
      ds.field("openTypeNameDescription", &self.openTypeNameDescription());
      ds.field("openTypeNamePreferredFamilyName", &self.openTypeNamePreferredFamilyName());
      ds.field("openTypeNamePreferredSubfamilyName", &self.openTypeNamePreferredSubfamilyName());
      ds.field("openTypeNameCompatibleFullName", &self.openTypeNameCompatibleFullName());
      ds.field("openTypeNameSampleText", &self.openTypeNameSampleText());
      ds.field("openTypeNameWWSFamilyName", &self.openTypeNameWWSFamilyName());
      ds.field("openTypeNameWWSSubfamilyName", &self.openTypeNameWWSSubfamilyName());
      ds.field("openTypeNameRecords", &self.openTypeNameRecords());
      ds.field("openTypeOS2WidthClass", &self.openTypeOS2WidthClass());
      ds.field("openTypeOS2WeightClass", &self.openTypeOS2WeightClass());
      ds.field("openTypeOS2Selection", &self.openTypeOS2Selection());
      ds.field("openTypeOS2VendorID", &self.openTypeOS2VendorID());
      ds.field("openTypeOS2Panose", &self.openTypeOS2Panose());
      ds.field("openTypeOS2FamilyClass", &self.openTypeOS2FamilyClass());
      ds.field("openTypeOS2UnicodeRanges", &self.openTypeOS2UnicodeRanges());
      ds.field("openTypeOS2CodePageRanges", &self.openTypeOS2CodePageRanges());
      ds.field("openTypeOS2TypoAscender", &self.openTypeOS2TypoAscender());
      ds.field("openTypeOS2TypoDescender", &self.openTypeOS2TypoDescender());
      ds.field("openTypeOS2TypoLineGap", &self.openTypeOS2TypoLineGap());
      ds.field("openTypeOS2WinAscent", &self.openTypeOS2WinAscent());
      ds.field("openTypeOS2WinDescent", &self.openTypeOS2WinDescent());
      ds.field("openTypeOS2SubscriptXSize", &self.openTypeOS2SubscriptXSize());
      ds.field("openTypeOS2SubscriptYSize", &self.openTypeOS2SubscriptYSize());
      ds.field("openTypeOS2SubscriptXOffset", &self.openTypeOS2SubscriptXOffset());
      ds.field("openTypeOS2SubscriptYOffset", &self.openTypeOS2SubscriptYOffset());
      ds.field("openTypeOS2SuperscriptXSize", &self.openTypeOS2SuperscriptXSize());
      ds.field("openTypeOS2SuperscriptYSize", &self.openTypeOS2SuperscriptYSize());
      ds.field("openTypeOS2SuperscriptXOffset", &self.openTypeOS2SuperscriptXOffset());
      ds.field("openTypeOS2SuperscriptYOffset", &self.openTypeOS2SuperscriptYOffset());
      ds.field("openTypeOS2StrikeoutSize", &self.openTypeOS2StrikeoutSize());
      ds.field("openTypeOS2StrikeoutPosition", &self.openTypeOS2StrikeoutPosition());
      ds.field("openTypeVheaVertTypoAscender", &self.openTypeVheaVertTypoAscender());
      ds.field("openTypeVheaVertTypoDescender", &self.openTypeVheaVertTypoDescender());
      ds.field("openTypeVheaVertTypoLineGap", &self.openTypeVheaVertTypoLineGap());
      ds.field("openTypeVheaCaretSlopeRise", &self.openTypeVheaCaretSlopeRise());
      ds.field("openTypeVheaCaretSlopeRun", &self.openTypeVheaCaretSlopeRun());
      ds.field("openTypeVheaCaretOffset", &self.openTypeVheaCaretOffset());
      ds.field("postscriptFontName", &self.postscriptFontName());
      ds.field("postscriptFullName", &self.postscriptFullName());
      ds.field("postscriptSlantAngle", &self.postscriptSlantAngle());
      ds.field("postscriptUniqueID", &self.postscriptUniqueID());
      ds.field("postscriptUnderlineThickness", &self.postscriptUnderlineThickness());
      ds.field("postscriptUnderlinePosition", &self.postscriptUnderlinePosition());
      ds.field("postscriptIsFixedPitch", &self.postscriptIsFixedPitch());
      ds.field("postscriptBlueValues", &self.postscriptBlueValues());
      ds.field("postscriptOtherBlues", &self.postscriptOtherBlues());
      ds.field("postscriptFamilyBlues", &self.postscriptFamilyBlues());
      ds.field("postscriptFamilyOtherBlues", &self.postscriptFamilyOtherBlues());
      ds.field("postscriptStemSnapH", &self.postscriptStemSnapH());
      ds.field("postscriptStemSnapV", &self.postscriptStemSnapV());
      ds.field("postscriptBlueFuzz", &self.postscriptBlueFuzz());
      ds.field("postscriptBlueShift", &self.postscriptBlueShift());
      ds.field("postscriptBlueScale", &self.postscriptBlueScale());
      ds.field("postscriptForceBold", &self.postscriptForceBold());
      ds.field("postscriptDefaultWidthX", &self.postscriptDefaultWidthX());
      ds.field("postscriptNominalWidthX", &self.postscriptNominalWidthX());
      ds.field("postscriptWeightName", &self.postscriptWeightName());
      ds.field("postscriptDefaultCharacter", &self.postscriptDefaultCharacter());
      ds.field("postscriptWindowsCharacterSet", &self.postscriptWindowsCharacterSet());
      ds.field("macintoshFONDFamilyID", &self.macintoshFONDFamilyID());
      ds.field("macintoshFONDName", &self.macintoshFONDName());
      ds.field("woffMajorVersion", &self.woffMajorVersion());
      ds.field("woffMinorVersion", &self.woffMinorVersion());
      ds.field("woffMetadataUniqueID", &self.woffMetadataUniqueID());
      ds.field("woffMetadataVendor", &self.woffMetadataVendor());
      ds.field("woffMetadataCredits", &self.woffMetadataCredits());
      ds.field("woffMetadataDescription", &self.woffMetadataDescription());
      ds.field("woffMetadataLicense", &self.woffMetadataLicense());
      ds.field("woffMetadataCopyright", &self.woffMetadataCopyright());
      ds.field("woffMetadataTrademark", &self.woffMetadataTrademark());
      ds.field("woffMetadataLicensee", &self.woffMetadataLicensee());
      ds.field("woffMetadataExtensions", &self.woffMetadataExtensions());
      ds.field("guidelines", &self.guidelines());
      ds.finish()
  }
}
pub enum OpenTypeNameRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OpenTypeNameRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OpenTypeNameRecord<'a> {
    type Inner = OpenTypeNameRecord<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> OpenTypeNameRecord<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OpenTypeNameRecord { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OpenTypeNameRecordArgs<'args>) -> flatbuffers::WIPOffset<OpenTypeNameRecord<'bldr>> {
      let mut builder = OpenTypeNameRecordBuilder::new(_fbb);
      if let Some(x) = args.string { builder.add_string(x); }
      builder.add_languageID(args.languageID);
      builder.add_encodingID(args.encodingID);
      builder.add_platformID(args.platformID);
      builder.add_nameID(args.nameID);
      builder.finish()
    }

    pub const VT_NAMEID: flatbuffers::VOffsetT = 4;
    pub const VT_PLATFORMID: flatbuffers::VOffsetT = 6;
    pub const VT_ENCODINGID: flatbuffers::VOffsetT = 8;
    pub const VT_LANGUAGEID: flatbuffers::VOffsetT = 10;
    pub const VT_STRING: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn nameID(&self) -> u16 {
    self._tab.get::<u16>(OpenTypeNameRecord::VT_NAMEID, Some(0)).unwrap()
  }
  #[inline]
  pub fn platformID(&self) -> u16 {
    self._tab.get::<u16>(OpenTypeNameRecord::VT_PLATFORMID, Some(0)).unwrap()
  }
  #[inline]
  pub fn encodingID(&self) -> u16 {
    self._tab.get::<u16>(OpenTypeNameRecord::VT_ENCODINGID, Some(0)).unwrap()
  }
  #[inline]
  pub fn languageID(&self) -> u16 {
    self._tab.get::<u16>(OpenTypeNameRecord::VT_LANGUAGEID, Some(0)).unwrap()
  }
  #[inline]
  pub fn string(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OpenTypeNameRecord::VT_STRING, None)
  }
}

impl flatbuffers::Verifiable for OpenTypeNameRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>(&"nameID", Self::VT_NAMEID, false)?
     .visit_field::<u16>(&"platformID", Self::VT_PLATFORMID, false)?
     .visit_field::<u16>(&"encodingID", Self::VT_ENCODINGID, false)?
     .visit_field::<u16>(&"languageID", Self::VT_LANGUAGEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"string", Self::VT_STRING, false)?
     .finish();
    Ok(())
  }
}
pub struct OpenTypeNameRecordArgs<'a> {
    pub nameID: u16,
    pub platformID: u16,
    pub encodingID: u16,
    pub languageID: u16,
    pub string: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OpenTypeNameRecordArgs<'a> {
    #[inline]
    fn default() -> Self {
        OpenTypeNameRecordArgs {
            nameID: 0,
            platformID: 0,
            encodingID: 0,
            languageID: 0,
            string: None,
        }
    }
}
pub struct OpenTypeNameRecordBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OpenTypeNameRecordBuilder<'a, 'b> {
  #[inline]
  pub fn add_nameID(&mut self, nameID: u16) {
    self.fbb_.push_slot::<u16>(OpenTypeNameRecord::VT_NAMEID, nameID, 0);
  }
  #[inline]
  pub fn add_platformID(&mut self, platformID: u16) {
    self.fbb_.push_slot::<u16>(OpenTypeNameRecord::VT_PLATFORMID, platformID, 0);
  }
  #[inline]
  pub fn add_encodingID(&mut self, encodingID: u16) {
    self.fbb_.push_slot::<u16>(OpenTypeNameRecord::VT_ENCODINGID, encodingID, 0);
  }
  #[inline]
  pub fn add_languageID(&mut self, languageID: u16) {
    self.fbb_.push_slot::<u16>(OpenTypeNameRecord::VT_LANGUAGEID, languageID, 0);
  }
  #[inline]
  pub fn add_string(&mut self, string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OpenTypeNameRecord::VT_STRING, string);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OpenTypeNameRecordBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OpenTypeNameRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OpenTypeNameRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for OpenTypeNameRecord<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("OpenTypeNameRecord");
      ds.field("nameID", &self.nameID());
      ds.field("platformID", &self.platformID());
      ds.field("encodingID", &self.encodingID());
      ds.field("languageID", &self.languageID());
      ds.field("string", &self.string());
      ds.finish()
  }
}
pub enum OpenTypeGaspRangeRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OpenTypeGaspRangeRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OpenTypeGaspRangeRecord<'a> {
    type Inner = OpenTypeGaspRangeRecord<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> OpenTypeGaspRangeRecord<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OpenTypeGaspRangeRecord { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OpenTypeGaspRangeRecordArgs<'args>) -> flatbuffers::WIPOffset<OpenTypeGaspRangeRecord<'bldr>> {
      let mut builder = OpenTypeGaspRangeRecordBuilder::new(_fbb);
      if let Some(x) = args.rangeGaspBehavior { builder.add_rangeGaspBehavior(x); }
      builder.add_rangeMaxPPEM(args.rangeMaxPPEM);
      builder.finish()
    }

    pub const VT_RANGEMAXPPEM: flatbuffers::VOffsetT = 4;
    pub const VT_RANGEGASPBEHAVIOR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn rangeMaxPPEM(&self) -> u32 {
    self._tab.get::<u32>(OpenTypeGaspRangeRecord::VT_RANGEMAXPPEM, Some(0)).unwrap()
  }
  #[inline]
  pub fn rangeGaspBehavior(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(OpenTypeGaspRangeRecord::VT_RANGEGASPBEHAVIOR, None)
  }
}

impl flatbuffers::Verifiable for OpenTypeGaspRangeRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>(&"rangeMaxPPEM", Self::VT_RANGEMAXPPEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(&"rangeGaspBehavior", Self::VT_RANGEGASPBEHAVIOR, false)?
     .finish();
    Ok(())
  }
}
pub struct OpenTypeGaspRangeRecordArgs<'a> {
    pub rangeMaxPPEM: u32,
    pub rangeGaspBehavior: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for OpenTypeGaspRangeRecordArgs<'a> {
    #[inline]
    fn default() -> Self {
        OpenTypeGaspRangeRecordArgs {
            rangeMaxPPEM: 0,
            rangeGaspBehavior: None,
        }
    }
}
pub struct OpenTypeGaspRangeRecordBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OpenTypeGaspRangeRecordBuilder<'a, 'b> {
  #[inline]
  pub fn add_rangeMaxPPEM(&mut self, rangeMaxPPEM: u32) {
    self.fbb_.push_slot::<u32>(OpenTypeGaspRangeRecord::VT_RANGEMAXPPEM, rangeMaxPPEM, 0);
  }
  #[inline]
  pub fn add_rangeGaspBehavior(&mut self, rangeGaspBehavior: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OpenTypeGaspRangeRecord::VT_RANGEGASPBEHAVIOR, rangeGaspBehavior);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OpenTypeGaspRangeRecordBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OpenTypeGaspRangeRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OpenTypeGaspRangeRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for OpenTypeGaspRangeRecord<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("OpenTypeGaspRangeRecord");
      ds.field("rangeMaxPPEM", &self.rangeMaxPPEM());
      ds.field("rangeGaspBehavior", &self.rangeGaspBehavior());
      ds.finish()
  }
}
pub enum WoffMetadataUniqueIDOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataUniqueID<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataUniqueID<'a> {
    type Inner = WoffMetadataUniqueID<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataUniqueID<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataUniqueID { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataUniqueIDArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataUniqueID<'bldr>> {
      let mut builder = WoffMetadataUniqueIDBuilder::new(_fbb);
      if let Some(x) = args.id { builder.add_id(x); }
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataUniqueID::VT_ID, None).unwrap()
  }
}

impl flatbuffers::Verifiable for WoffMetadataUniqueID<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"id", Self::VT_ID, true)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataUniqueIDArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for WoffMetadataUniqueIDArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataUniqueIDArgs {
            id: None, // required field
        }
    }
}
pub struct WoffMetadataUniqueIDBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataUniqueIDBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataUniqueID::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataUniqueIDBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataUniqueIDBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataUniqueID<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, WoffMetadataUniqueID::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataUniqueID<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataUniqueID");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum WoffMetadataVendorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataVendor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataVendor<'a> {
    type Inner = WoffMetadataVendor<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataVendor<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataVendor { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataVendorArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataVendor<'bldr>> {
      let mut builder = WoffMetadataVendorBuilder::new(_fbb);
      if let Some(x) = args.class { builder.add_class(x); }
      if let Some(x) = args.dir { builder.add_dir(x); }
      if let Some(x) = args.url { builder.add_url(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_URL: flatbuffers::VOffsetT = 6;
    pub const VT_DIR: flatbuffers::VOffsetT = 8;
    pub const VT_CLASS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataVendor::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn url(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataVendor::VT_URL, None)
  }
  #[inline]
  pub fn dir(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataVendor::VT_DIR, None)
  }
  #[inline]
  pub fn class(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataVendor::VT_CLASS, None)
  }
}

impl flatbuffers::Verifiable for WoffMetadataVendor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"url", Self::VT_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"dir", Self::VT_DIR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"class", Self::VT_CLASS, false)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataVendorArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dir: Option<flatbuffers::WIPOffset<&'a str>>,
    pub class: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for WoffMetadataVendorArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataVendorArgs {
            name: None, // required field
            url: None,
            dir: None,
            class: None,
        }
    }
}
pub struct WoffMetadataVendorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataVendorBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataVendor::VT_NAME, name);
  }
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataVendor::VT_URL, url);
  }
  #[inline]
  pub fn add_dir(&mut self, dir: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataVendor::VT_DIR, dir);
  }
  #[inline]
  pub fn add_class(&mut self, class: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataVendor::VT_CLASS, class);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataVendorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataVendorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataVendor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, WoffMetadataVendor::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataVendor<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataVendor");
      ds.field("name", &self.name());
      ds.field("url", &self.url());
      ds.field("dir", &self.dir());
      ds.field("class", &self.class());
      ds.finish()
  }
}
pub enum WoffMetadataCreditsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataCredits<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataCredits<'a> {
    type Inner = WoffMetadataCredits<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataCredits<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataCredits { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataCreditsArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataCredits<'bldr>> {
      let mut builder = WoffMetadataCreditsBuilder::new(_fbb);
      if let Some(x) = args.credits { builder.add_credits(x); }
      builder.finish()
    }

    pub const VT_CREDITS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn credits(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataCredit<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataCredit>>>>(WoffMetadataCredits::VT_CREDITS, None)
  }
}

impl flatbuffers::Verifiable for WoffMetadataCredits<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WoffMetadataCredit>>>>(&"credits", Self::VT_CREDITS, false)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataCreditsArgs<'a> {
    pub credits: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataCredit<'a>>>>>,
}
impl<'a> Default for WoffMetadataCreditsArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataCreditsArgs {
            credits: None,
        }
    }
}
pub struct WoffMetadataCreditsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataCreditsBuilder<'a, 'b> {
  #[inline]
  pub fn add_credits(&mut self, credits: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WoffMetadataCredit<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataCredits::VT_CREDITS, credits);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataCreditsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataCreditsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataCredits<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataCredits<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataCredits");
      ds.field("credits", &self.credits());
      ds.finish()
  }
}
pub enum WoffMetadataCreditOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataCredit<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataCredit<'a> {
    type Inner = WoffMetadataCredit<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataCredit<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataCredit { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataCreditArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataCredit<'bldr>> {
      let mut builder = WoffMetadataCreditBuilder::new(_fbb);
      if let Some(x) = args.class { builder.add_class(x); }
      if let Some(x) = args.dir { builder.add_dir(x); }
      if let Some(x) = args.role { builder.add_role(x); }
      if let Some(x) = args.url { builder.add_url(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_URL: flatbuffers::VOffsetT = 6;
    pub const VT_ROLE: flatbuffers::VOffsetT = 8;
    pub const VT_DIR: flatbuffers::VOffsetT = 10;
    pub const VT_CLASS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataCredit::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn url(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataCredit::VT_URL, None)
  }
  #[inline]
  pub fn role(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataCredit::VT_ROLE, None)
  }
  #[inline]
  pub fn dir(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataCredit::VT_DIR, None)
  }
  #[inline]
  pub fn class(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataCredit::VT_CLASS, None)
  }
}

impl flatbuffers::Verifiable for WoffMetadataCredit<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"url", Self::VT_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"role", Self::VT_ROLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"dir", Self::VT_DIR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"class", Self::VT_CLASS, false)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataCreditArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub role: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dir: Option<flatbuffers::WIPOffset<&'a str>>,
    pub class: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for WoffMetadataCreditArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataCreditArgs {
            name: None, // required field
            url: None,
            role: None,
            dir: None,
            class: None,
        }
    }
}
pub struct WoffMetadataCreditBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataCreditBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataCredit::VT_NAME, name);
  }
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataCredit::VT_URL, url);
  }
  #[inline]
  pub fn add_role(&mut self, role: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataCredit::VT_ROLE, role);
  }
  #[inline]
  pub fn add_dir(&mut self, dir: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataCredit::VT_DIR, dir);
  }
  #[inline]
  pub fn add_class(&mut self, class: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataCredit::VT_CLASS, class);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataCreditBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataCreditBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataCredit<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, WoffMetadataCredit::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataCredit<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataCredit");
      ds.field("name", &self.name());
      ds.field("url", &self.url());
      ds.field("role", &self.role());
      ds.field("dir", &self.dir());
      ds.field("class", &self.class());
      ds.finish()
  }
}
pub enum WoffMetadataDescriptionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataDescription<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataDescription<'a> {
    type Inner = WoffMetadataDescription<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataDescription<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataDescription { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataDescriptionArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataDescription<'bldr>> {
      let mut builder = WoffMetadataDescriptionBuilder::new(_fbb);
      if let Some(x) = args.text { builder.add_text(x); }
      if let Some(x) = args.url { builder.add_url(x); }
      builder.finish()
    }

    pub const VT_URL: flatbuffers::VOffsetT = 4;
    pub const VT_TEXT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn url(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataDescription::VT_URL, None)
  }
  #[inline]
  pub fn text(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataText<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataText>>>>(WoffMetadataDescription::VT_TEXT, None)
  }
}

impl flatbuffers::Verifiable for WoffMetadataDescription<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"url", Self::VT_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WoffMetadataText>>>>(&"text", Self::VT_TEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataDescriptionArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataText<'a>>>>>,
}
impl<'a> Default for WoffMetadataDescriptionArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataDescriptionArgs {
            url: None,
            text: None,
        }
    }
}
pub struct WoffMetadataDescriptionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataDescriptionBuilder<'a, 'b> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataDescription::VT_URL, url);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WoffMetadataText<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataDescription::VT_TEXT, text);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataDescriptionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataDescriptionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataDescription<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataDescription<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataDescription");
      ds.field("url", &self.url());
      ds.field("text", &self.text());
      ds.finish()
  }
}
pub enum WoffMetadataLicenseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataLicense<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataLicense<'a> {
    type Inner = WoffMetadataLicense<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataLicense<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataLicense { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataLicenseArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataLicense<'bldr>> {
      let mut builder = WoffMetadataLicenseBuilder::new(_fbb);
      if let Some(x) = args.text { builder.add_text(x); }
      if let Some(x) = args.id { builder.add_id(x); }
      if let Some(x) = args.url { builder.add_url(x); }
      builder.finish()
    }

    pub const VT_URL: flatbuffers::VOffsetT = 4;
    pub const VT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_TEXT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn url(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataLicense::VT_URL, None)
  }
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataLicense::VT_ID, None)
  }
  #[inline]
  pub fn text(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataText<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataText>>>>(WoffMetadataLicense::VT_TEXT, None)
  }
}

impl flatbuffers::Verifiable for WoffMetadataLicense<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"url", Self::VT_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WoffMetadataText>>>>(&"text", Self::VT_TEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataLicenseArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataText<'a>>>>>,
}
impl<'a> Default for WoffMetadataLicenseArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataLicenseArgs {
            url: None,
            id: None,
            text: None,
        }
    }
}
pub struct WoffMetadataLicenseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataLicenseBuilder<'a, 'b> {
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataLicense::VT_URL, url);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataLicense::VT_ID, id);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WoffMetadataText<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataLicense::VT_TEXT, text);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataLicenseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataLicenseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataLicense<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataLicense<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataLicense");
      ds.field("url", &self.url());
      ds.field("id", &self.id());
      ds.field("text", &self.text());
      ds.finish()
  }
}
pub enum WoffMetadataCopyrightOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataCopyright<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataCopyright<'a> {
    type Inner = WoffMetadataCopyright<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataCopyright<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataCopyright { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataCopyrightArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataCopyright<'bldr>> {
      let mut builder = WoffMetadataCopyrightBuilder::new(_fbb);
      if let Some(x) = args.text { builder.add_text(x); }
      builder.finish()
    }

    pub const VT_TEXT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn text(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataText<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataText>>>>(WoffMetadataCopyright::VT_TEXT, None)
  }
}

impl flatbuffers::Verifiable for WoffMetadataCopyright<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WoffMetadataText>>>>(&"text", Self::VT_TEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataCopyrightArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataText<'a>>>>>,
}
impl<'a> Default for WoffMetadataCopyrightArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataCopyrightArgs {
            text: None,
        }
    }
}
pub struct WoffMetadataCopyrightBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataCopyrightBuilder<'a, 'b> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WoffMetadataText<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataCopyright::VT_TEXT, text);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataCopyrightBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataCopyrightBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataCopyright<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataCopyright<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataCopyright");
      ds.field("text", &self.text());
      ds.finish()
  }
}
pub enum WoffMetadataTrademarkOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataTrademark<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataTrademark<'a> {
    type Inner = WoffMetadataTrademark<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataTrademark<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataTrademark { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataTrademarkArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataTrademark<'bldr>> {
      let mut builder = WoffMetadataTrademarkBuilder::new(_fbb);
      if let Some(x) = args.text { builder.add_text(x); }
      builder.finish()
    }

    pub const VT_TEXT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn text(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataText<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataText>>>>(WoffMetadataTrademark::VT_TEXT, None)
  }
}

impl flatbuffers::Verifiable for WoffMetadataTrademark<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WoffMetadataText>>>>(&"text", Self::VT_TEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataTrademarkArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataText<'a>>>>>,
}
impl<'a> Default for WoffMetadataTrademarkArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataTrademarkArgs {
            text: None,
        }
    }
}
pub struct WoffMetadataTrademarkBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataTrademarkBuilder<'a, 'b> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WoffMetadataText<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataTrademark::VT_TEXT, text);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataTrademarkBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataTrademarkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataTrademark<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataTrademark<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataTrademark");
      ds.field("text", &self.text());
      ds.finish()
  }
}
pub enum WoffMetadataLicenseeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataLicensee<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataLicensee<'a> {
    type Inner = WoffMetadataLicensee<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataLicensee<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataLicensee { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataLicenseeArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataLicensee<'bldr>> {
      let mut builder = WoffMetadataLicenseeBuilder::new(_fbb);
      if let Some(x) = args.class { builder.add_class(x); }
      if let Some(x) = args.dir { builder.add_dir(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DIR: flatbuffers::VOffsetT = 6;
    pub const VT_CLASS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataLicensee::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn dir(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataLicensee::VT_DIR, None)
  }
  #[inline]
  pub fn class(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataLicensee::VT_CLASS, None)
  }
}

impl flatbuffers::Verifiable for WoffMetadataLicensee<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"dir", Self::VT_DIR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"class", Self::VT_CLASS, false)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataLicenseeArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dir: Option<flatbuffers::WIPOffset<&'a str>>,
    pub class: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for WoffMetadataLicenseeArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataLicenseeArgs {
            name: None, // required field
            dir: None,
            class: None,
        }
    }
}
pub struct WoffMetadataLicenseeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataLicenseeBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataLicensee::VT_NAME, name);
  }
  #[inline]
  pub fn add_dir(&mut self, dir: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataLicensee::VT_DIR, dir);
  }
  #[inline]
  pub fn add_class(&mut self, class: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataLicensee::VT_CLASS, class);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataLicenseeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataLicenseeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataLicensee<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, WoffMetadataLicensee::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataLicensee<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataLicensee");
      ds.field("name", &self.name());
      ds.field("dir", &self.dir());
      ds.field("class", &self.class());
      ds.finish()
  }
}
pub enum WoffMetadataTextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataText<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataText<'a> {
    type Inner = WoffMetadataText<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataText<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataText { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataTextArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataText<'bldr>> {
      let mut builder = WoffMetadataTextBuilder::new(_fbb);
      if let Some(x) = args.class { builder.add_class(x); }
      if let Some(x) = args.dir { builder.add_dir(x); }
      if let Some(x) = args.language { builder.add_language(x); }
      if let Some(x) = args.text { builder.add_text(x); }
      builder.finish()
    }

    pub const VT_TEXT: flatbuffers::VOffsetT = 4;
    pub const VT_LANGUAGE: flatbuffers::VOffsetT = 6;
    pub const VT_DIR: flatbuffers::VOffsetT = 8;
    pub const VT_CLASS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn text(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataText::VT_TEXT, None).unwrap()
  }
  #[inline]
  pub fn language(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataText::VT_LANGUAGE, None)
  }
  #[inline]
  pub fn dir(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataText::VT_DIR, None)
  }
  #[inline]
  pub fn class(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataText::VT_CLASS, None)
  }
}

impl flatbuffers::Verifiable for WoffMetadataText<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"text", Self::VT_TEXT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"language", Self::VT_LANGUAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"dir", Self::VT_DIR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"class", Self::VT_CLASS, false)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataTextArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub language: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dir: Option<flatbuffers::WIPOffset<&'a str>>,
    pub class: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for WoffMetadataTextArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataTextArgs {
            text: None, // required field
            language: None,
            dir: None,
            class: None,
        }
    }
}
pub struct WoffMetadataTextBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataTextBuilder<'a, 'b> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataText::VT_TEXT, text);
  }
  #[inline]
  pub fn add_language(&mut self, language: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataText::VT_LANGUAGE, language);
  }
  #[inline]
  pub fn add_dir(&mut self, dir: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataText::VT_DIR, dir);
  }
  #[inline]
  pub fn add_class(&mut self, class: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataText::VT_CLASS, class);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataTextBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataTextBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataText<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, WoffMetadataText::VT_TEXT,"text");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataText<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataText");
      ds.field("text", &self.text());
      ds.field("language", &self.language());
      ds.field("dir", &self.dir());
      ds.field("class", &self.class());
      ds.finish()
  }
}
pub enum WoffMetadataExtensionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataExtension<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataExtension<'a> {
    type Inner = WoffMetadataExtension<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataExtension<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataExtension { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataExtensionArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataExtension<'bldr>> {
      let mut builder = WoffMetadataExtensionBuilder::new(_fbb);
      if let Some(x) = args.items { builder.add_items(x); }
      if let Some(x) = args.names { builder.add_names(x); }
      if let Some(x) = args.id { builder.add_id(x); }
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAMES: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataExtension::VT_ID, None)
  }
  #[inline]
  pub fn names(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtensionName<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtensionName>>>>(WoffMetadataExtension::VT_NAMES, None)
  }
  #[inline]
  pub fn items(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtensionItem<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtensionItem>>>>(WoffMetadataExtension::VT_ITEMS, None)
  }
}

impl flatbuffers::Verifiable for WoffMetadataExtension<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WoffMetadataExtensionName>>>>(&"names", Self::VT_NAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WoffMetadataExtensionItem>>>>(&"items", Self::VT_ITEMS, false)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataExtensionArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub names: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtensionName<'a>>>>>,
    pub items: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtensionItem<'a>>>>>,
}
impl<'a> Default for WoffMetadataExtensionArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataExtensionArgs {
            id: None,
            names: None,
            items: None,
        }
    }
}
pub struct WoffMetadataExtensionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataExtensionBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtension::VT_ID, id);
  }
  #[inline]
  pub fn add_names(&mut self, names: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WoffMetadataExtensionName<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtension::VT_NAMES, names);
  }
  #[inline]
  pub fn add_items(&mut self, items: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WoffMetadataExtensionItem<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtension::VT_ITEMS, items);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataExtensionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataExtensionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataExtension<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataExtension<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataExtension");
      ds.field("id", &self.id());
      ds.field("names", &self.names());
      ds.field("items", &self.items());
      ds.finish()
  }
}
pub enum WoffMetadataExtensionItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataExtensionItem<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataExtensionItem<'a> {
    type Inner = WoffMetadataExtensionItem<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataExtensionItem<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataExtensionItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataExtensionItemArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataExtensionItem<'bldr>> {
      let mut builder = WoffMetadataExtensionItemBuilder::new(_fbb);
      if let Some(x) = args.values { builder.add_values(x); }
      if let Some(x) = args.names { builder.add_names(x); }
      if let Some(x) = args.id { builder.add_id(x); }
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAMES: flatbuffers::VOffsetT = 6;
    pub const VT_VALUES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataExtensionItem::VT_ID, None)
  }
  #[inline]
  pub fn names(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtensionName<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtensionName>>>>(WoffMetadataExtensionItem::VT_NAMES, None)
  }
  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtensionValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtensionValue>>>>(WoffMetadataExtensionItem::VT_VALUES, None)
  }
}

impl flatbuffers::Verifiable for WoffMetadataExtensionItem<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WoffMetadataExtensionName>>>>(&"names", Self::VT_NAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WoffMetadataExtensionValue>>>>(&"values", Self::VT_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataExtensionItemArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub names: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtensionName<'a>>>>>,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WoffMetadataExtensionValue<'a>>>>>,
}
impl<'a> Default for WoffMetadataExtensionItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataExtensionItemArgs {
            id: None,
            names: None,
            values: None,
        }
    }
}
pub struct WoffMetadataExtensionItemBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataExtensionItemBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtensionItem::VT_ID, id);
  }
  #[inline]
  pub fn add_names(&mut self, names: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WoffMetadataExtensionName<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtensionItem::VT_NAMES, names);
  }
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WoffMetadataExtensionValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtensionItem::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataExtensionItemBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataExtensionItemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataExtensionItem<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataExtensionItem<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataExtensionItem");
      ds.field("id", &self.id());
      ds.field("names", &self.names());
      ds.field("values", &self.values());
      ds.finish()
  }
}
pub enum WoffMetadataExtensionNameOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataExtensionName<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataExtensionName<'a> {
    type Inner = WoffMetadataExtensionName<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataExtensionName<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataExtensionName { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataExtensionNameArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataExtensionName<'bldr>> {
      let mut builder = WoffMetadataExtensionNameBuilder::new(_fbb);
      if let Some(x) = args.class { builder.add_class(x); }
      if let Some(x) = args.dir { builder.add_dir(x); }
      if let Some(x) = args.language { builder.add_language(x); }
      if let Some(x) = args.text { builder.add_text(x); }
      builder.finish()
    }

    pub const VT_TEXT: flatbuffers::VOffsetT = 4;
    pub const VT_LANGUAGE: flatbuffers::VOffsetT = 6;
    pub const VT_DIR: flatbuffers::VOffsetT = 8;
    pub const VT_CLASS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn text(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataExtensionName::VT_TEXT, None).unwrap()
  }
  #[inline]
  pub fn language(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataExtensionName::VT_LANGUAGE, None)
  }
  #[inline]
  pub fn dir(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataExtensionName::VT_DIR, None)
  }
  #[inline]
  pub fn class(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataExtensionName::VT_CLASS, None)
  }
}

impl flatbuffers::Verifiable for WoffMetadataExtensionName<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"text", Self::VT_TEXT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"language", Self::VT_LANGUAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"dir", Self::VT_DIR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"class", Self::VT_CLASS, false)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataExtensionNameArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub language: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dir: Option<flatbuffers::WIPOffset<&'a str>>,
    pub class: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for WoffMetadataExtensionNameArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataExtensionNameArgs {
            text: None, // required field
            language: None,
            dir: None,
            class: None,
        }
    }
}
pub struct WoffMetadataExtensionNameBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataExtensionNameBuilder<'a, 'b> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtensionName::VT_TEXT, text);
  }
  #[inline]
  pub fn add_language(&mut self, language: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtensionName::VT_LANGUAGE, language);
  }
  #[inline]
  pub fn add_dir(&mut self, dir: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtensionName::VT_DIR, dir);
  }
  #[inline]
  pub fn add_class(&mut self, class: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtensionName::VT_CLASS, class);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataExtensionNameBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataExtensionNameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataExtensionName<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, WoffMetadataExtensionName::VT_TEXT,"text");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataExtensionName<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataExtensionName");
      ds.field("text", &self.text());
      ds.field("language", &self.language());
      ds.field("dir", &self.dir());
      ds.field("class", &self.class());
      ds.finish()
  }
}
pub enum WoffMetadataExtensionValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WoffMetadataExtensionValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WoffMetadataExtensionValue<'a> {
    type Inner = WoffMetadataExtensionValue<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> WoffMetadataExtensionValue<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        WoffMetadataExtensionValue { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WoffMetadataExtensionValueArgs<'args>) -> flatbuffers::WIPOffset<WoffMetadataExtensionValue<'bldr>> {
      let mut builder = WoffMetadataExtensionValueBuilder::new(_fbb);
      if let Some(x) = args.class { builder.add_class(x); }
      if let Some(x) = args.dir { builder.add_dir(x); }
      if let Some(x) = args.language { builder.add_language(x); }
      if let Some(x) = args.text { builder.add_text(x); }
      builder.finish()
    }

    pub const VT_TEXT: flatbuffers::VOffsetT = 4;
    pub const VT_LANGUAGE: flatbuffers::VOffsetT = 6;
    pub const VT_DIR: flatbuffers::VOffsetT = 8;
    pub const VT_CLASS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn text(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataExtensionValue::VT_TEXT, None).unwrap()
  }
  #[inline]
  pub fn language(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataExtensionValue::VT_LANGUAGE, None)
  }
  #[inline]
  pub fn dir(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataExtensionValue::VT_DIR, None)
  }
  #[inline]
  pub fn class(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WoffMetadataExtensionValue::VT_CLASS, None)
  }
}

impl flatbuffers::Verifiable for WoffMetadataExtensionValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"text", Self::VT_TEXT, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"language", Self::VT_LANGUAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"dir", Self::VT_DIR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"class", Self::VT_CLASS, false)?
     .finish();
    Ok(())
  }
}
pub struct WoffMetadataExtensionValueArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub language: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dir: Option<flatbuffers::WIPOffset<&'a str>>,
    pub class: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for WoffMetadataExtensionValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        WoffMetadataExtensionValueArgs {
            text: None, // required field
            language: None,
            dir: None,
            class: None,
        }
    }
}
pub struct WoffMetadataExtensionValueBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WoffMetadataExtensionValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtensionValue::VT_TEXT, text);
  }
  #[inline]
  pub fn add_language(&mut self, language: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtensionValue::VT_LANGUAGE, language);
  }
  #[inline]
  pub fn add_dir(&mut self, dir: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtensionValue::VT_DIR, dir);
  }
  #[inline]
  pub fn add_class(&mut self, class: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WoffMetadataExtensionValue::VT_CLASS, class);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WoffMetadataExtensionValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WoffMetadataExtensionValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WoffMetadataExtensionValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, WoffMetadataExtensionValue::VT_TEXT,"text");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for WoffMetadataExtensionValue<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("WoffMetadataExtensionValue");
      ds.field("text", &self.text());
      ds.field("language", &self.language());
      ds.field("dir", &self.dir());
      ds.field("class", &self.class());
      ds.finish()
  }
}
pub enum GuildelineOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Guildeline<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Guildeline<'a> {
    type Inner = Guildeline<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Guildeline<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Guildeline { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GuildelineArgs<'args>) -> flatbuffers::WIPOffset<Guildeline<'bldr>> {
      let mut builder = GuildelineBuilder::new(_fbb);
      if let Some(x) = args.identifier { builder.add_identifier(x); }
      if let Some(x) = args.color { builder.add_color(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_angle(args.angle);
      builder.add_y(args.y);
      builder.add_x(args.x);
      builder.finish()
    }

    pub const VT_X: flatbuffers::VOffsetT = 4;
    pub const VT_Y: flatbuffers::VOffsetT = 6;
    pub const VT_ANGLE: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_COLOR: flatbuffers::VOffsetT = 12;
    pub const VT_IDENTIFIER: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn x(&self) -> f32 {
    self._tab.get::<f32>(Guildeline::VT_X, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn y(&self) -> f32 {
    self._tab.get::<f32>(Guildeline::VT_Y, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn angle(&self) -> f32 {
    self._tab.get::<f32>(Guildeline::VT_ANGLE, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Guildeline::VT_NAME, None)
  }
  #[inline]
  pub fn color(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Guildeline::VT_COLOR, None)
  }
  #[inline]
  pub fn identifier(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Guildeline::VT_IDENTIFIER, None)
  }
}

impl flatbuffers::Verifiable for Guildeline<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>(&"x", Self::VT_X, false)?
     .visit_field::<f32>(&"y", Self::VT_Y, false)?
     .visit_field::<f32>(&"angle", Self::VT_ANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"color", Self::VT_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"identifier", Self::VT_IDENTIFIER, false)?
     .finish();
    Ok(())
  }
}
pub struct GuildelineArgs<'a> {
    pub x: f32,
    pub y: f32,
    pub angle: f32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub identifier: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for GuildelineArgs<'a> {
    #[inline]
    fn default() -> Self {
        GuildelineArgs {
            x: 0.0,
            y: 0.0,
            angle: 0.0,
            name: None,
            color: None,
            identifier: None,
        }
    }
}
pub struct GuildelineBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GuildelineBuilder<'a, 'b> {
  #[inline]
  pub fn add_x(&mut self, x: f32) {
    self.fbb_.push_slot::<f32>(Guildeline::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f32) {
    self.fbb_.push_slot::<f32>(Guildeline::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn add_angle(&mut self, angle: f32) {
    self.fbb_.push_slot::<f32>(Guildeline::VT_ANGLE, angle, 0.0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Guildeline::VT_NAME, name);
  }
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Guildeline::VT_COLOR, color);
  }
  #[inline]
  pub fn add_identifier(&mut self, identifier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Guildeline::VT_IDENTIFIER, identifier);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GuildelineBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GuildelineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Guildeline<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Guildeline<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Guildeline");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("angle", &self.angle());
      ds.field("name", &self.name());
      ds.field("color", &self.color());
      ds.field("identifier", &self.identifier());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_font_info<'a>(buf: &'a [u8]) -> FontInfo<'a> {
  unsafe { flatbuffers::root_unchecked::<FontInfo<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_font_info<'a>(buf: &'a [u8]) -> FontInfo<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<FontInfo<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `FontInfo`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_font_info_unchecked`.
pub fn root_as_font_info(buf: &[u8]) -> Result<FontInfo, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<FontInfo>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `FontInfo` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_font_info_unchecked`.
pub fn size_prefixed_root_as_font_info(buf: &[u8]) -> Result<FontInfo, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<FontInfo>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `FontInfo` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_font_info_unchecked`.
pub fn root_as_font_info_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FontInfo<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<FontInfo<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `FontInfo` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_font_info_unchecked`.
pub fn size_prefixed_root_as_font_info_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FontInfo<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<FontInfo<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a FontInfo and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `FontInfo`.
pub unsafe fn root_as_font_info_unchecked(buf: &[u8]) -> FontInfo {
  flatbuffers::root_unchecked::<FontInfo>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed FontInfo and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `FontInfo`.
pub unsafe fn size_prefixed_root_as_font_info_unchecked(buf: &[u8]) -> FontInfo {
  flatbuffers::size_prefixed_root_unchecked::<FontInfo>(buf)
}
#[inline]
pub fn finish_font_info_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<FontInfo<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_font_info_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<FontInfo<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
